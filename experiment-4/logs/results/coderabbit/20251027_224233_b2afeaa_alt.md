# Alternative Code Review Report (Pattern Matching)

**Generated**: 2025-10-27 22:42:33
**Commit**: `b2afeaa` (`HEAD`)
**Review Type**: Alternative Implementation

---

## ğŸ“Š Quick Summary

- **Lines Added**: 0
- **Lines Removed**: 0
- **Net Change**: 0 lines
- **Total Issues Detected**: 3
  - ğŸ”´ Critical: 1
  - ğŸŸ  High: 1
  - ğŸŸ¡ Medium: 1
  - ğŸŸ¢ Low: 00
- **AI Analysis**: âœ… Performed

---


## â„¹ï¸  Review Mode

This is an **alternative implementation** review, used when CodeRabbit CLI is not available.

- âœ… Basic pattern matching
- âœ… Security analysis
- âœ… Code quality checks
- âš ï¸  Limited to git diff analysis

## ğŸ“‹ Commit Information

- **Commit**: `HEAD` (`b2afeaa`)
- **Date**: 2025å¹´ 10æœˆ 27æ—¥ æœˆæ›œæ—¥ 22:41:25 JST
- **Author**: Self-Review Experiment <experiment@multi-ai-orchestrium>
- **Message**: 6-droid implementation for self-review experiment

## ğŸ“Š Code Changes

```diff
diff --git a/app.js b/app.js
new file mode 100644
index 0000000..8e22cc8
--- /dev/null
+++ b/app.js
@@ -0,0 +1,1415 @@
+(() => {
+  "use strict";
+
+  const CONFIG = Object.freeze({
+    storageKeys: Object.freeze({
+      tasks: "pomotodo_tasks",
+      timer: "pomotodo_timer",
+      settings: "pomotodo_settings",
+      today: "pomotodo_today",
+      history: "pomotodo_history",
+      selection: "pomotodo_selection"
+    }),
+    limits: Object.freeze({
+      titleMax: 100,
+      estimate: Object.freeze({ min: 1, max: 20 }),
+      durations: Object.freeze({
+        work: Object.freeze({ min: 1, max: 60 }),
+        shortBreak: Object.freeze({ min: 1, max: 30 }),
+        longBreak: Object.freeze({ min: 5, max: 60 })
+      })
+    }),
+    defaults: Object.freeze({
+      settings: Object.freeze({
+        workDuration: 25,
+        shortBreakDuration: 5,
+        longBreakDuration: 15,
+        longBreakInterval: 4,
+        notificationSound: "beep",
+        focusMode: false,
+        filterState: "all"
+      })
+    }),
+    historyLimit: 30
+  });
+  const ERRORS = {
+    E001: "E001: ã‚¿ã‚¹ã‚¯åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„",
+    E002: `E002: ã‚¿ã‚¹ã‚¯åã¯${CONFIG.limits.titleMax}æ–‡å­—ä»¥å†…ã§å…¥åŠ›ã—ã¦ãã ã•ã„`,
+    E003: "E003: ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„",
+    E004: "E004: ã‚¿ã‚¤ãƒãƒ¼ã‚’åœæ­¢ã—ã¦ã‹ã‚‰å‰Šé™¤ã—ã¦ãã ã•ã„",
+    E005: "E005: ä¿å­˜å®¹é‡ãŒä¸è¶³ã—ã¦ã„ã¾ã™",
+    E006: "E006: ä¿å­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ",
+    E007: "E007: ã‚¿ã‚¤ãƒãƒ¼ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ",
+    E008: "E008: ç·¨é›†ã‚’å®Œäº†ã—ã¦ãã ã•ã„",
+    E009: `E009: è¦‹ç©ã‚‚ã‚Šã¯${CONFIG.limits.estimate.min}ã€œ${CONFIG.limits.estimate.max}ã®ç¯„å›²ã§å…¥åŠ›ã—ã¦ãã ã•ã„`,
+    E010: "E010: ã‚¿ã‚¤ãƒãƒ¼ã‚’åœæ­¢ã—ã¦ã‹ã‚‰é¸æŠã—ã¦ãã ã•ã„",
+    E011: "E011: é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ä¸­ã¯æ“ä½œã§ãã¾ã›ã‚“"
+  };
+  const QA_MATRIX = Object.freeze([
+    Object.freeze({ area: "Todo", scenario: "ã‚¿ã‚¹ã‚¯è¿½åŠ /ç·¨é›†/å‰Šé™¤", expectation: "100msä»¥å†…ã«DOMã¸åæ˜ " }),
+    Object.freeze({ area: "Timer", scenario: "é–‹å§‹â†’å®Œäº†", expectation: "25åˆ†å¾Œã«é€šçŸ¥ãƒ»ä¼‘æ†©ã¸é·ç§»" }),
+    Object.freeze({ area: "Persistence", scenario: "ãƒªãƒ­ãƒ¼ãƒ‰å¾Œã®çŠ¶æ…‹å¾©å…ƒ", expectation: "ã‚¿ã‚¹ã‚¯ãƒ»ã‚¿ã‚¤ãƒãƒ¼ãƒ»è¨­å®šãŒä¿æŒã•ã‚Œã‚‹" }),
+    Object.freeze({ area: "Accessibility", scenario: "ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ", expectation: "Tab/Space/Enterã§å…¨æ“ä½œå¯èƒ½" })
+  ]);
+  const AUDIO_PROFILES = Object.freeze({
+    beep: Object.freeze([
+      Object.freeze({ frequency: 880, duration: 0.18, gain: 0.35, type: "sine" }),
+      Object.freeze({ gap: 0.12 }),
+      Object.freeze({ frequency: 880, duration: 0.18, gain: 0.35, type: "sine" }),
+      Object.freeze({ gap: 0.12 }),
+      Object.freeze({ frequency: 880, duration: 0.18, gain: 0.35, type: "sine" })
+    ]),
+    bell: Object.freeze([
+      Object.freeze({ frequency: 660, duration: 0.45, gain: 0.4, type: "triangle", decay: 0.8 }),
+      Object.freeze({ gap: 0.1 }),
+      Object.freeze({ frequency: 880, duration: 0.3, gain: 0.25, type: "sine", decay: 0.7 })
+    ]),
+    chime: Object.freeze([
+      Object.freeze({ frequency: 523.25, duration: 0.22, gain: 0.28, type: "sine" }),
+      Object.freeze({ gap: 0.06 }),
+      Object.freeze({ frequency: 659.25, duration: 0.22, gain: 0.28, type: "sine" }),
+      Object.freeze({ gap: 0.06 }),
+      Object.freeze({ frequency: 783.99, duration: 0.24, gain: 0.28, type: "sine" })
+    ])
+  });
+  const AUDIO_FALLBACK_SRC = "data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=";
+  const DEFAULT_SETTINGS = { ...CONFIG.defaults.settings };
+  const state = {
+    tasks: [],
+    history: [],
+    timer: createTimerState(),
+    settings: { ...DEFAULT_SETTINGS },
+    selectedTaskId: null,
+    today: createToday(),
+    ui: { searchTerm: "", editingTaskId: null, focusLocked: false, lastCreatedTaskId: null }
+  };
+  const dom = {};
+  const bus = createEventBus();
+  let timerId = null;
+  let audioContext = null;
+  let fallbackAudio = null;
+  document.addEventListener("DOMContentLoaded", init);
+  function init() {
+    cacheDom();
+    registerObservers();
+    loadState();
+    attachEvents();
+    bus.emit("tasks:updated", state.tasks);
+    bus.emit("timer:updated", state.timer);
+    bus.emit("settings:updated", state.settings);
+    bus.emit("history:updated", state.history);
+    applyFocusState();
+    requestNotificationPermission();
+  }
+
+  function cacheDom() {
+    Object.assign(dom, {
+      taskForm: document.getElementById("task-form"),
+      taskFormError: document.getElementById("task-form-error"),
+      taskTitle: document.getElementById("task-title"),
+      taskEstimate: document.getElementById("task-estimate"),
+      taskSearch: document.getElementById("task-search"),
+      sortCreatedBtn: document.getElementById("sort-created-btn"),
+      sortEstimateBtn: document.getElementById("sort-estimate-btn"),
+      bulkDeleteBtn: document.getElementById("bulk-delete-btn"),
+      taskList: document.getElementById("task-list"),
+      taskEmptyState: document.getElementById("task-empty-state"),
+      filterButtons: Array.from(document.querySelectorAll(".filter-btn")),
+      notification: document.getElementById("notification"),
+      timerMode: document.getElementById("timer-mode"),
+      timerDisplay: document.getElementById("timer-display"),
+      progressBar: document.getElementById("progress-bar"),
+      currentTask: document.getElementById("current-task"),
+      startBtn: document.getElementById("start-btn"),
+      pauseBtn: document.getElementById("pause-btn"),
+      resetBtn: document.getElementById("reset-btn"),
+      skipBtn: document.getElementById("skip-btn"),
+      weeklyChart: document.getElementById("weekly-chart"),
+      statTodayPomodoros: document.getElementById("stat-today-pomodoros"),
+      statTodayTasks: document.getElementById("stat-today-tasks"),
+      statTodayTime: document.getElementById("stat-today-time"),
+      statListPomodoros: document.getElementById("stat-list-pomodoros"),
+      statListTasks: document.getElementById("stat-list-tasks"),
+      statListTime: document.getElementById("stat-list-time"),
+      statStreak: document.getElementById("stat-streak"),
+      confirmDialog: document.getElementById("confirm-dialog"),
+      confirmMessage: document.getElementById("confirm-message"),
+      toggleFocusBtn: document.getElementById("toggle-focus-btn"),
+      openSettingsBtn: document.getElementById("open-settings-btn"),
+      exportBtn: document.getElementById("export-btn"),
+      importInput: document.getElementById("import-input"),
+      settingsDialog: document.getElementById("settings-dialog"),
+      settingsForm: document.getElementById("settings-form"),
+      settingsWorkDuration: document.getElementById("settings-work-duration"),
+      settingsShortBreak: document.getElementById("settings-short-break"),
+      settingsLongBreak: document.getElementById("settings-long-break"),
+      settingsLongInterval: document.getElementById("settings-long-interval"),
+      settingsSound: document.getElementById("settings-sound"),
+      settingsFocusMode: document.getElementById("settings-focus-mode"),
+      settingsFilterDefault: document.getElementById("settings-filter-default"),
+      settingsResetBtn: document.getElementById("settings-reset-btn"),
+      settingsSaveBtn: document.getElementById("settings-save-btn"),
+      focusOverlay: document.getElementById("focus-overlay"),
+    });
+  }
+
+  function registerObservers() {
+    bus.on("tasks:updated", () => {
+      renderTasks();
+      updateStatistics();
+    });
+    bus.on("timer:updated", () => {
+      updateTimerDisplay();
+      applyFocusState();
+    });
+    bus.on("settings:updated", () => {
+      updateFilterButtons();
+      renderTasks();
+      updateStatistics();
+      applyFocusState();
+    });
+    bus.on("history:updated", () => {
+      if (typeof renderWeeklyChart === "function") renderWeeklyChart();
+    });
+  }
+  function loadState() {
+    state.tasks = load(CONFIG.storageKeys.tasks, []).map(normalizeTask).filter(Boolean);
+    state.settings = normalizeSettings({ ...DEFAULT_SETTINGS, ...load(CONFIG.storageKeys.settings, {}) });
+    state.history = load(CONFIG.storageKeys.history, []).map(normalizeHistoryEntry).filter(Boolean);
+    if (state.history.length > CONFIG.historyLimit) {
+      state.history = state.history.slice(-CONFIG.historyLimit);
+      persistHistory();
+    }
+    const storedSelection = load(CONFIG.storageKeys.selection, null);
+    const timer = load(CONFIG.storageKeys.timer, null);
+    state.timer = timer ? normalizeTimer(timer) : createTimerState();
+    if (state.timer.isRunning) resumeFromPersisted(); else syncDuration(state.timer.mode || "work");
+    const today = load(CONFIG.storageKeys.today, null);
+    state.today = normalizeToday(today) ?? createToday();
+    if (state.today.date !== formatDateKey(new Date())) ensureToday(); else persistToday();
+    if (storedSelection && state.tasks.some((t) => t.id === storedSelection)) state.selectedTaskId = storedSelection; else state.selectedTaskId = null;
+    const inferred = inferSelectedTask();
+    if (inferred) state.selectedTaskId = inferred;
+    if (state.selectedTaskId && !state.tasks.some((t) => t.id === state.selectedTaskId)) state.selectedTaskId = null;
+    if (!state.timer.isRunning && (state.timer.mode === "idle" || state.timer.mode === "work")) {
+      state.timer.currentTaskId = state.selectedTaskId;
+    }
+    persistSelection();
+    updateFilterButtons();
+  }
+
+  function attachEvents() {
+    dom.taskForm.addEventListener("submit", onTaskSubmit);
+    dom.filterButtons.forEach((btn) => btn.addEventListener("click", () => setFilter(btn.dataset.filter)));
+    dom.taskList.addEventListener("click", onTaskClick);
+    dom.taskList.addEventListener("change", onTaskChange);
+    dom.taskList.addEventListener("dblclick", onTaskDoubleClick);
+    dom.taskSearch?.addEventListener("input", handleTaskSearch);
+    dom.taskTitle.addEventListener("input", () => clearFormError());
+    dom.taskEstimate.addEventListener("input", () => clearFormError());
+    dom.startBtn.addEventListener("click", startTimer);
+    dom.pauseBtn.addEventListener("click", pauseTimer);
+    dom.resetBtn.addEventListener("click", () => resetTimer(true));
+    dom.skipBtn.addEventListener("click", skipTimer);
+    dom.toggleFocusBtn?.addEventListener("click", toggleFocusMode);
+    dom.openSettingsBtn?.addEventListener("click", openSettingsDialog);
+    dom.settingsForm?.addEventListener("submit", handleSettingsSubmit);
+    dom.settingsResetBtn?.addEventListener("click", resetSettingsForm);
+    dom.settingsDialog?.addEventListener("cancel", () => dom.settingsDialog.close("cancel"));
+    dom.settingsDialog?.addEventListener("close", () => populateSettingsForm());
+    dom.bulkDeleteBtn?.addEventListener("click", bulkDeleteCompleted);
+    dom.exportBtn?.addEventListener("click", exportData);
+    dom.importInput?.addEventListener("change", handleDataImport);
+    document.addEventListener("visibilitychange", () => {
+      if (document.visibilityState === "visible" && state.timer.isRunning) updateTimer();
+    });
+    document.addEventListener("keydown", handleGlobalKeys);
+  }
+
+  function onTaskSubmit(event) {
+    event.preventDefault();
+    if (guardFocusMode()) return;
+    if (state.ui.editingTaskId) {
+      showNotification(ERRORS.E008, "warning");
+      return;
+    }
+    const title = dom.taskTitle.value.trim();
+    const estimate = Number(dom.taskEstimate.value);
+    const { ok, message } = validateTask(title, estimate);
+    if (!ok) {
+      showFormError(message);
+      dom.taskTitle.focus();
+      return;
+    }
+    clearFormError();
+    addTask(title, estimate);
+    dom.taskTitle.value = "";
+    dom.taskEstimate.value = "1";
+  }
+
+  function handleTaskSearch(event) {
+    if (isFocusLocked()) {
+      event.target.value = state.ui.searchTerm;
+      showNotification(ERRORS.E011, "warning");
+      return;
+    }
+    state.ui.searchTerm = event.target.value.trim().toLowerCase();
+    bus.emit("tasks:updated", state.tasks);
+  }
+
+  function guardEditing(event) {
+    if (!state.ui.editingTaskId) return false;
+    if (event?.target?.closest?.(".task-edit-form")) return false;
+    showNotification(ERRORS.E008, "warning");
+    return true;
+  }
+
+  function getTaskProgress(task) {
+    const estimate = Math.max(task.estimatedPomodoros || 1, 1);
+    const ratio = task.actualPomodoros / estimate;
+    let state = "not-started";
+    if (ratio === 0) state = "not-started";
+    else if (ratio < 1) state = "in-progress";
+    else if (ratio === 1) state = "met";
+    else state = "over";
+    return { ratio, clampedRatio: Math.min(ratio, 1), state };
+  }
+
+  function isFocusLocked() {
+    return Boolean(state.settings.focusMode && state.timer.isRunning);
+  }
+
+  function guardFocusMode() {
+    if (!isFocusLocked()) return false;
+    showNotification(ERRORS.E011, "warning");
+    return true;
+  }
+
+  function onTaskClick(event) {
+    if (guardFocusMode()) return;
+    if (guardEditing(event)) return;
+    const item = event.target.closest(".task-item");
+    if (!item) return;
+    const id = item.dataset.taskId;
+    if (event.target.matches(".edit-btn")) {
+      enterEditMode(id);
+      return;
+    }
+    else if (event.target.matches(".delete-btn")) queueDelete(id, item);
+    else if (!event.target.matches(".task-checkbox")) selectTask(id);
+  }
+
+  function onTaskChange(event) {
+    if (isFocusLocked()) {
+      event.preventDefault();
+      showNotification(ERRORS.E011, "warning");
+      return;
+    }
+    if (state.ui.editingTaskId) {
+      event.preventDefault();
+      showNotification(ERRORS.E008, "warning");
+      return;
+    }
+    if (!event.target.matches(".task-checkbox")) return;
+    const item = event.target.closest(".task-item");
+    if (!item) return;
+    toggleComplete(item.dataset.taskId, event.target.checked);
+  }
+
+  function onTaskDoubleClick(event) {
+    if (state.ui.editingTaskId) {
+      if (!event.target.closest(`[data-task-id="${state.ui.editingTaskId}"]`)) showNotification(ERRORS.E008, "warning");
+      return;
+    }
+    const item = event.target.closest(".task-item");
+    if (!item) return;
+    event.preventDefault();
+    enterEditMode(item.dataset.taskId);
+  }
+
+  function handleGlobalKeys(event) {
+    if (isFocusLocked() && ["Delete", " "].includes(event.key)) {
+      event.preventDefault();
+      showNotification(ERRORS.E011, "warning");
+      return;
+    }
+    if (state.ui.editingTaskId && event.key !== "Escape" && !event.target.closest?.(".task-edit-form")) {
+      if (["Delete", " ", "Enter"].includes(event.key)) {
+        showNotification(ERRORS.E008, "warning");
+        event.preventDefault();
+        return;
+      }
+    }
+    if (event.key === "Escape" && state.ui.editingTaskId) {
+      cancelEdit();
+      return;
+    }
+    if (event.key === "Enter" && document.activeElement === dom.taskTitle) dom.taskForm.requestSubmit();
+    else if (event.key === "Escape" && dom.confirmDialog?.open) dom.confirmDialog.close("cancel");
+    else if (event.key === " " && document.activeElement?.closest(".task-item") && !event.target.matches("input,button")) {
+      selectTask(document.activeElement.closest(".task-item").dataset.taskId);
+      event.preventDefault();
+    } else if (event.key === "Delete") {
+      const focused = document.activeElement?.closest(".task-item");
+      if (focused) queueDelete(focused.dataset.taskId, focused);
+    } else if (event.key === "Enter" && state.timer.isPaused) startTimer();
+  }
+
+  function validateTask(title, estimate) {
+    if (!title) return { ok: false, message: ERRORS.E001 };
+    if (title.length > CONFIG.limits.titleMax) return { ok: false, message: ERRORS.E002 };
+    if (!Number.isInteger(estimate) || estimate < CONFIG.limits.estimate.min || estimate > CONFIG.limits.estimate.max) return { ok: false, message: ERRORS.E009 };
+    return { ok: true };
+  }
+
+  function showFormError(message) {
+    if (!dom.taskFormError) return;
+    dom.taskFormError.textContent = message;
+    dom.taskFormError.hidden = false;
+  }
+
+  function clearFormError() {
+    if (!dom.taskFormError) return;
+    dom.taskFormError.textContent = "";
+    dom.taskFormError.hidden = true;
+  }
+
+  function addTask(title, estimatedPomodoros) {
+    const task = createTask({ title, estimatedPomodoros });
+    state.tasks.unshift(task);
+    state.ui.lastCreatedTaskId = task.id;
+    commitTasks();
+    showNotification("ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã—ãŸ", "success");
+  }
+
+  function enterEditMode(taskId) {
+    if (state.ui.editingTaskId === taskId) return;
+    const task = state.tasks.find((t) => t.id === taskId);
+    if (!task) return;
+    state.ui.editingTaskId = taskId;
+    bus.emit("tasks:updated", state.tasks);
+    requestAnimationFrame(() => {
+      const input = dom.taskList.querySelector(".task-edit-input");
+      input?.focus();
+      input?.select();
+    });
+  }
+
+  function cancelEdit() {
+    if (!state.ui.editingTaskId) return;
+    state.ui.editingTaskId = null;
+    bus.emit("tasks:updated", state.tasks);
+  }
+
+  function applyTaskEdit(taskId, title) {
+    const task = state.tasks.find((t) => t.id === taskId);
+    if (!task) return cancelEdit();
+    const { ok, message } = validateTask(title, task.estimatedPomodoros);
+    if (!ok) {
+      showNotification(message, "error");
+      return;
+    }
+    if (title === task.title) {
+      cancelEdit();
+      return;
+    }
+    task.title = title;
+    state.ui.editingTaskId = null;
+    commitTasks();
+    showNotification("ã‚¿ã‚¹ã‚¯ã‚’æ›´æ–°ã—ã¾ã—ãŸ", "success");
+  }
+
+  function queueDelete(taskId, element) {
+    if (isFocusLocked()) return showNotification(ERRORS.E011, "warning");
+    if (state.timer.isRunning && state.timer.currentTaskId === taskId) return showNotification(ERRORS.E004, "warning");
+    element.classList.add("removing");
+    setTimeout(() => deleteTask(taskId), 260);
+  }
+
+  function deleteTask(taskId) {
+    const index = state.tasks.findIndex((t) => t.id === taskId);
+    if (index === -1) return;
+    const [removed] = state.tasks.splice(index, 1);
+    if (state.selectedTaskId === removed.id) {
+      state.selectedTaskId = null;
+      if (!state.timer.isRunning) state.timer.currentTaskId = null;
+    }
+    if (state.ui.editingTaskId === removed.id) state.ui.editingTaskId = null;
+    commitTasks();
+    persistSelection();
+    showNotification("ã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ", "info");
+  }
+
+  function toggleComplete(taskId, completed) {
+    const task = state.tasks.find((t) => t.id === taskId);
+    if (!task) return;
+    task.completed = completed;
+    task.completedAt = completed ? nowISO() : null;
+    if (completed && state.timer.currentTaskId === taskId && !state.timer.isRunning) {
+      state.selectedTaskId = null;
+      state.timer.currentTaskId = null;
+      persistSelection();
+    }
+    commitTasks();
+  }
+
+  function selectTask(taskId) {
+    if (state.timer.isRunning && state.timer.currentTaskId !== taskId) return showNotification(ERRORS.E010, "warning");
+    state.selectedTaskId = taskId;
+    if (!state.timer.isRunning) state.timer.currentTaskId = taskId;
+    bus.emit("tasks:updated", state.tasks);
+    bus.emit("timer:updated", state.timer);
+    persistSelection();
+  }
+
+  function setFilter(filter) {
+    state.settings.filterState = filter;
+    commitSettings();
+    bus.emit("tasks:updated", state.tasks);
+  }
+
+  function updateFilterButtons() {
+    dom.filterButtons.forEach((btn) => btn.classList.toggle("active", btn.dataset.filter === state.settings.filterState));
+  }
+
+  function renderTasks() {
+    const tasks = getTasksByFilter();
+    const fragment = document.createDocumentFragment();
+    dom.taskList.textContent = "";
+    if (dom.taskEmptyState) {
+      if (tasks.length === 0) {
+        dom.taskEmptyState.textContent = state.ui.searchTerm ? "è©²å½“ã™ã‚‹ã‚¿ã‚¹ã‚¯ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã€‚" : "ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æœ€åˆã®ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã—ã‚‡ã†ã€‚";
+        dom.taskEmptyState.hidden = false;
+      } else dom.taskEmptyState.hidden = true;
+    }
+    tasks.forEach((task) => fragment.appendChild(buildTaskItem(task)));
+    dom.taskList.appendChild(fragment);
+    if (state.ui.lastCreatedTaskId) state.ui.lastCreatedTaskId = null;
+  }
+
+  function getTasksByFilter() {
+    const { filterState } = state.settings;
+    let tasks = state.tasks;
+    if (filterState === "active") tasks = tasks.filter((t) => !t.completed);
+    else if (filterState === "completed") tasks = tasks.filter((t) => t.completed);
+    else tasks = tasks.slice();
+    if (state.ui.searchTerm) {
+      const query = state.ui.searchTerm;
+      tasks = tasks.filter((t) => t.title.toLowerCase().includes(query));
+    }
+    if (filterState === "all") {
+      tasks = tasks.slice().sort((a, b) => {
+        if (a.completed === b.completed) return 0;
+        return a.completed ? 1 : -1;
+      });
+    }
+    return tasks;
+  }
+
+  function buildTaskItem(task) {
+    const li = document.createElement("li");
+    const isEditing = state.ui.editingTaskId === task.id;
+    li.className = "task-item";
+    li.dataset.taskId = task.id;
+    li.tabIndex = 0;
+    if (task.id === state.selectedTaskId) li.classList.add("selected");
+    if (task.completed) li.classList.add("completed");
+    if (isEditing) li.classList.add("editing");
+
+    if (isEditing) {
+      const progress = getTaskProgress(task);
+      const form = document.createElement("form");
+      form.className = "task-edit-form";
+
+      const input = document.createElement("input");
+      input.type = "text";
+      input.className = "task-edit-input";
+      input.value = task.title;
+      input.maxLength = CONFIG.limits.titleMax;
+      input.setAttribute("aria-label", `${task.title} ã‚’ç·¨é›†`);
+      input.required = true;
+      input.addEventListener("keydown", (evt) => {
+        if (evt.key === "Escape") {
+          evt.preventDefault();
+          cancelEdit();
+        }
+      });
+
+      const meta = document.createElement("div");
+      meta.className = `task-edit-meta task-meta-summary task-meta-summary--${progress.state}`;
+      meta.textContent = `ğŸ… ${task.actualPomodoros}/${task.estimatedPomodoros}`;
+
+      const progressBar = document.createElement("div");
+      progressBar.className = `task-progress task-progress--${progress.state}`;
+      progressBar.setAttribute("role", "progressbar");
+      progressBar.setAttribute("aria-valuemin", "0");
+      progressBar.setAttribute("aria-valuemax", `${task.estimatedPomodoros}`);
+      progressBar.setAttribute("aria-valuenow", `${Math.min(task.actualPomodoros, task.estimatedPomodoros)}`);
+      progressBar.setAttribute("aria-label", `${task.title} ã®é€²æ— ${task.actualPomodoros}/${task.estimatedPomodoros}`);
+      const progressFill = document.createElement("div");
+      progressFill.className = "task-progress__fill";
+      progressFill.style.width = `${Math.round(progress.clampedRatio * 100)}%`;
+      progressBar.append(progressFill);
+
+      const actions = document.createElement("div");
+      actions.className = "task-edit-actions";
+      const saveBtn = document.createElement("button");
+      saveBtn.type = "submit";
+      saveBtn.className = "btn btn-primary task-edit-save";
+      saveBtn.textContent = "ä¿å­˜";
+      const cancelBtn = document.createElement("button");
+      cancelBtn.type = "button";
+      cancelBtn.className = "btn btn-secondary task-edit-cancel";
+      cancelBtn.textContent = "ã‚­ãƒ£ãƒ³ã‚»ãƒ«";
+      cancelBtn.addEventListener("click", () => cancelEdit());
+      actions.append(saveBtn, cancelBtn);
+
+      form.append(input, meta, progressBar, actions);
+      form.addEventListener("submit", (evt) => {
+        evt.preventDefault();
+        applyTaskEdit(task.id, input.value.trim());
+      });
+
+      li.append(form);
+      return li;
+    }
+
+    const checkbox = document.createElement("input");
+    checkbox.type = "checkbox";
+    checkbox.className = "task-checkbox";
+    checkbox.checked = task.completed;
+    checkbox.setAttribute("aria-label", `${task.title} ã‚’å®Œäº†ã«ã™ã‚‹`);
+
+    const content = document.createElement("div");
+    content.className = "task-content";
+    const title = document.createElement("span");
+    title.className = "task-title-text";
+    title.textContent = task.title;
+    const meta = document.createElement("div");
+    meta.className = "task-meta";
+    const progress = getTaskProgress(task);
+    const summary = document.createElement("span");
+    summary.className = `task-meta-summary task-meta-summary--${progress.state}`;
+    summary.textContent = `ğŸ… ${task.actualPomodoros}/${task.estimatedPomodoros}`;
+    const created = document.createElement("span");
+    created.textContent = new Date(task.createdAt).toLocaleString();
+    meta.append(summary, created);
+    content.append(title, meta);
+
+    const progressBar = document.createElement("div");
+    progressBar.className = `task-progress task-progress--${progress.state}`;
+    progressBar.setAttribute("role", "progressbar");
+    progressBar.setAttribute("aria-valuemin", "0");
+    progressBar.setAttribute("aria-valuemax", `${task.estimatedPomodoros}`);
+    progressBar.setAttribute("aria-valuenow", `${Math.min(task.actualPomodoros, task.estimatedPomodoros)}`);
+    progressBar.setAttribute("aria-label", `${task.title} ã®é€²æ— ${task.actualPomodoros}/${task.estimatedPomodoros}`);
+    const progressFill = document.createElement("div");
+    progressFill.className = "task-progress__fill";
+    progressFill.style.width = `${Math.round(progress.clampedRatio * 100)}%`;
+    progressBar.append(progressFill);
+    content.append(progressBar);
+
+    const actions = document.createElement("div");
+    actions.className = "task-actions";
+    const edit = document.createElement("button");
+    edit.type = "button";
+    edit.className = "edit-btn";
+    edit.textContent = "âœï¸";
+    edit.setAttribute("aria-label", `${task.title} ã‚’ç·¨é›†`);
+    const del = document.createElement("button");
+    del.type = "button";
+    del.className = "delete-btn";
+    del.textContent = "âœ•";
+    del.setAttribute("aria-label", `${task.title} ã‚’å‰Šé™¤`);
+    actions.append(edit, del);
+
+    li.append(checkbox, content, actions);
+    if (task.id === state.ui.lastCreatedTaskId) {
+      li.classList.add("new");
+      setTimeout(() => li.classList.remove("new"), 400);
+    }
+    return li;
+  }
+
+  function startTimer() {
+    if (state.ui.editingTaskId) return showNotification(ERRORS.E008, "warning");
+    if (state.timer.isRunning && !state.timer.isPaused) return;
+    const isWorkPhase = state.timer.mode === "work" || state.timer.mode === "idle";
+    if (isWorkPhase && !state.selectedTaskId) return showNotification(ERRORS.E003, "warning");
+    state.timer.currentTaskId = isWorkPhase ? state.selectedTaskId : null;
+    if (state.timer.isPaused) {
+      state.timer.isPaused = false;
+      state.timer.startedAt = Date.now() - (state.timer.duration - state.timer.remainingTime) * 1000;
+    } else {
+      if (state.timer.mode === "idle") syncDuration("work");
+      state.timer.startedAt = Date.now();
+      state.timer.remainingTime = state.timer.duration;
+    }
+    state.timer.isRunning = true;
+    clearInterval(timerId);
+    timerId = setInterval(updateTimer, 1000);
+    updateTimer();
+    commitTimer();
+    dom.timerMode.parentElement?.classList.add("running");
+  }
+
+  function pauseTimer() {
+    if (!state.timer.isRunning) return;
+    clearInterval(timerId);
+    timerId = null;
+    state.timer.isRunning = false;
+    state.timer.isPaused = true;
+    commitTimer();
+    updateTimerDisplay();
+    dom.timerMode.parentElement?.classList.remove("running");
+  }
+
+  async function resetTimer(ask) {
+    if (ask && state.timer.remainingTime !== state.timer.duration) {
+      const confirmed = await confirmAction(ERRORS.E007);
+      if (!confirmed) return;
+    }
+    clearInterval(timerId);
+    timerId = null;
+    state.timer.isRunning = false;
+    state.timer.isPaused = false;
+    syncDuration(state.timer.mode === "idle" ? "work" : state.timer.mode);
+    state.timer.currentTaskId = state.selectedTaskId;
+    commitTimer();
+    updateTimerDisplay();
+    dom.timerMode.parentElement?.classList.remove("running");
+  }
+
+  function skipTimer() {
+    if (state.ui.editingTaskId) return showNotification(ERRORS.E008, "warning");
+    if (state.timer.mode === "idle") return;
+    clearInterval(timerId);
+    timerId = null;
+    dom.timerMode.parentElement?.classList.remove("running");
+    if (state.timer.mode === "work") {
+      const nextIsLongBreak = (state.timer.sessionCounter + 1) % state.settings.longBreakInterval === 0 && state.settings.longBreakInterval > 0;
+      switchMode(nextIsLongBreak ? "longBreak" : "shortBreak");
+      state.timer.currentTaskId = null;
+      state.timer.isRunning = false;
+      state.timer.isPaused = false;
+      commitTimer();
+      startTimer();
+      showNotification("ä½œæ¥­ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸã€‚ä¼‘æ†©ã«åˆ‡ã‚Šæ›¿ãˆã¾ã™", "info");
+    } else {
+      switchToWork();
+      showNotification("ä¼‘æ†©ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã—ãŸã€‚ä½œæ¥­ãƒ¢ãƒ¼ãƒ‰ã«æˆ»ã‚Šã¾ã™", "info");
+    }
+  }
+
+  function updateTimer() {
+    if (!state.timer.isRunning) return;
+    const elapsed = Math.floor((Date.now() - state.timer.startedAt) / 1000);
+    const nextRemaining = Math.max(state.timer.duration - elapsed, 0);
+    if (nextRemaining === state.timer.remainingTime) return;
+    state.timer.remainingTime = nextRemaining;
+    commitTimer();
+    if (state.timer.remainingTime <= 0) completeSession();
+  }
+
+  function completeSession() {
+    clearInterval(timerId);
+    timerId = null;
+    state.timer.isRunning = false;
+    state.timer.isPaused = false;
+    dom.timerMode.parentElement?.classList.remove("running");
+    playSound();
+    notify("ã‚¿ã‚¤ãƒãƒ¼ãŒçµ‚äº†ã—ã¾ã—ãŸ");
+    let tasksMutated = false;
+    if (state.timer.mode === "work") {
+      applyPomodoroResults();
+      tasksMutated = true;
+      proceedToBreak();
+      showNotification("ä½œæ¥­ã‚»ãƒƒã‚·ãƒ§ãƒ³å®Œäº†ï¼ä¼‘æ†©ã«å…¥ã‚Šã¾ã—ã‚‡ã†", "success");
+    } else {
+      switchToWork();
+      showNotification("ä¼‘æ†©çµ‚äº†ã€‚æ¬¡ã®ä½œæ¥­ã‚’é–‹å§‹ã—ã¾ã—ã‚‡ã†", "info");
+    }
+    commitTimer();
+    if (tasksMutated) commitTasks(); else bus.emit("tasks:updated", state.tasks);
+  }
+
+  function proceedToBreak() {
+    state.timer.pomodoroCount += 1;
+    state.timer.sessionCounter += 1;
+    const longBreak = state.timer.sessionCounter % state.settings.longBreakInterval === 0;
+    switchMode(longBreak ? "longBreak" : "shortBreak");
+    startTimer();
+  }
+
+  function switchToWork() {
+    switchMode("work");
+    if (state.selectedTaskId) startTimer();
+  }
+
+  function switchMode(mode) {
+    state.timer.mode = mode;
+    syncDuration(mode);
+    state.timer.remainingTime = state.timer.duration;
+    state.timer.startedAt = null;
+    state.timer.isRunning = false;
+    state.timer.isPaused = false;
+    state.timer.currentTaskId = mode === "work" ? state.selectedTaskId : null;
+  }
+
+  function syncDuration(mode) {
+    const minutes = mode === "shortBreak" ? state.settings.shortBreakDuration : mode === "longBreak" ? state.settings.longBreakDuration : state.settings.workDuration;
+    state.timer.duration = minutes * 60;
+    if (mode === "idle") state.timer.remainingTime = state.timer.duration;
+  }
+
+  function applyPomodoroResults() {
+    const task = state.tasks.find((t) => t.id === state.timer.currentTaskId);
+    if (!task) return;
+    task.actualPomodoros += 1;
+    if (task.actualPomodoros >= task.estimatedPomodoros && !task.completed) {
+      task.completed = true;
+      task.completedAt = nowISO();
+    }
+    const today = ensureToday();
+    today.pomodoros += 1;
+    today.streak += 1;
+    today.completedTasks = state.tasks.filter((t) => t.completed).length;
+    persistToday();
+  }
+
+  function updateTimerDisplay() {
+    const { mode, remainingTime, duration, currentTaskId } = state.timer;
+    dom.timerDisplay.textContent = formatTime(Math.max(remainingTime, 0));
+    dom.timerMode.textContent = modeLabel(mode);
+    dom.timerMode.style.color = modeColor(mode);
+    dom.progressBar.style.width = `${Math.min(Math.max(1 - remainingTime / (duration || 1), 0), 1) * 100}%`;
+    const task = state.tasks.find((t) => t.id === currentTaskId);
+    if (mode === "work") dom.currentTask.textContent = task ? `é¸æŠä¸­: ${task.title}` : "é¸æŠä¸­: ãªã—";
+    else if (mode === "shortBreak") dom.currentTask.textContent = "çŸ­ã„ä¼‘æ†©ã‚’å–ã‚Šã¾ã—ã‚‡ã†";
+    else if (mode === "longBreak") dom.currentTask.textContent = "é•·ã‚ã®ä¼‘æ†©ã§ãƒªãƒ•ãƒ¬ãƒƒã‚·ãƒ¥";
+    else dom.currentTask.textContent = "å¾…æ©Ÿä¸­: ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦ãã ã•ã„";
+  }
+
+  function updateStatistics() {
+    const today = ensureToday();
+    const completed = state.tasks.filter((t) => t.completed).length;
+    const total = state.tasks.length;
+    const minutes = today.pomodoros * state.settings.workDuration;
+    const hours = Math.floor(minutes / 60);
+    const rest = minutes % 60;
+    dom.statTodayPomodoros.textContent = `ğŸ… ${today.pomodoros}`;
+    dom.statTodayTasks.textContent = `âœ“ ${completed}/${total}`;
+    dom.statTodayTime.textContent = `${hours}h ${rest}m`;
+    dom.statListPomodoros.textContent = `ğŸ… ${today.pomodoros}`;
+    dom.statListTasks.textContent = `âœ“ ${completed}/${total}`;
+    dom.statListTime.textContent = `${hours}h ${rest}m`;
+    if (dom.statStreak) dom.statStreak.textContent = `${today.streak}`;
+    if (today.completedTasks !== completed) {
+      today.completedTasks = completed;
+      persistToday();
+    }
+    renderWeeklyChart();
+  }
+
+  function renderWeeklyChart() {
+    if (!dom.weeklyChart) return;
+    dom.weeklyChart.textContent = "";
+    const hasData = state.today.pomodoros > 0 || state.history.some((entry) => entry?.pomodoros);
+    if (!hasData) {
+      const placeholder = document.createElement("div");
+      placeholder.className = "weekly-chart__placeholder";
+      placeholder.textContent = "ãƒ‡ãƒ¼ã‚¿ãŒé›†ã¾ã‚‹ã¨ã“ã“ã«é€±é–“ã‚°ãƒ©ãƒ•ãŒè¡¨ç¤ºã•ã‚Œã¾ã™ã€‚";
+      dom.weeklyChart.appendChild(placeholder);
+    }
+  }
+
+  function applyFocusState() {
+    const focusEnabled = Boolean(state.settings.focusMode);
+    if (dom.toggleFocusBtn) {
+      dom.toggleFocusBtn.setAttribute("aria-pressed", focusEnabled ? "true" : "false");
+      dom.toggleFocusBtn.textContent = focusEnabled ? "é›†ä¸­ãƒ¢ãƒ¼ãƒ‰: ON" : "é›†ä¸­ãƒ¢ãƒ¼ãƒ‰: OFF";
+    }
+    const locked = isFocusLocked();
+    if (dom.focusOverlay) dom.focusOverlay.classList.toggle("active", locked);
+    if (dom.taskTitle) dom.taskTitle.disabled = locked;
+    if (dom.taskEstimate) dom.taskEstimate.disabled = locked;
+    if (dom.taskSearch) dom.taskSearch.disabled = locked;
+    [dom.bulkDeleteBtn, dom.sortCreatedBtn, dom.sortEstimateBtn].forEach((btn) => {
+      if (btn) btn.disabled = locked;
+    });
+    dom.taskForm?.classList.toggle("is-disabled", locked);
+    document.body.classList.toggle("focus-locked", locked);
+  }
+
+  function populateSettingsForm() {
+    if (!dom.settingsForm) return;
+    dom.settingsWorkDuration.value = String(state.settings.workDuration);
+    dom.settingsShortBreak.value = String(state.settings.shortBreakDuration);
+    dom.settingsLongBreak.value = String(state.settings.longBreakDuration);
+    dom.settingsLongInterval.value = String(state.settings.longBreakInterval);
+    dom.settingsSound.value = state.settings.notificationSound;
+    dom.settingsFocusMode.checked = Boolean(state.settings.focusMode);
+    dom.settingsFilterDefault.value = state.settings.filterState;
+  }
+
+  function openSettingsDialog() {
+    if (!dom.settingsDialog) return;
+    populateSettingsForm();
+    dom.settingsDialog.showModal();
+  }
+
+  function resetSettingsForm(event) {
+    event?.preventDefault();
+    if (!dom.settingsForm) return;
+    dom.settingsWorkDuration.value = String(DEFAULT_SETTINGS.workDuration);
+    dom.settingsShortBreak.value = String(DEFAULT_SETTINGS.shortBreakDuration);
+    dom.settingsLongBreak.value = String(DEFAULT_SETTINGS.longBreakDuration);
+    dom.settingsLongInterval.value = String(DEFAULT_SETTINGS.longBreakInterval);
+    dom.settingsSound.value = DEFAULT_SETTINGS.notificationSound;
+    dom.settingsFocusMode.checked = Boolean(DEFAULT_SETTINGS.focusMode);
+    dom.settingsFilterDefault.value = DEFAULT_SETTINGS.filterState;
+  }
+
+  function handleSettingsSubmit(event) {
+    event.preventDefault();
+    if (!dom.settingsForm) return;
+    const workDuration = Number(dom.settingsWorkDuration.value);
+    const shortBreak = Number(dom.settingsShortBreak.value);
+    const longBreak = Number(dom.settingsLongBreak.value);
+    const longInterval = Number(dom.settingsLongInterval.value);
+    const notificationSound = ["beep", "bell", "chime", "silent"].includes(dom.settingsSound.value) ? dom.settingsSound.value : DEFAULT_SETTINGS.notificationSound;
+    const focusMode = Boolean(dom.settingsFocusMode.checked);
+    const filterState = ["all", "active", "completed"].includes(dom.settingsFilterDefault.value) ? dom.settingsFilterDefault.value : state.settings.filterState;
+    const constraints = [
+      { value: workDuration, min: CONFIG.limits.durations.work.min, max: CONFIG.limits.durations.work.max, field: dom.settingsWorkDuration, message: `ä½œæ¥­æ™‚é–“ã¯${CONFIG.limits.durations.work.min}ã€œ${CONFIG.limits.durations.work.max}åˆ†ã§è¨­å®šã—ã¦ãã ã•ã„` },
+      { value: shortBreak, min: CONFIG.limits.durations.shortBreak.min, max: CONFIG.limits.durations.shortBreak.max, field: dom.settingsShortBreak, message: `çŸ­ã„ä¼‘æ†©ã¯${CONFIG.limits.durations.shortBreak.min}ã€œ${CONFIG.limits.durations.shortBreak.max}åˆ†ã§è¨­å®šã—ã¦ãã ã•ã„` },
+      { value: longBreak, min: CONFIG.limits.durations.longBreak.min, max: CONFIG.limits.durations.longBreak.max, field: dom.settingsLongBreak, message: `é•·ã„ä¼‘æ†©ã¯${CONFIG.limits.durations.longBreak.min}ã€œ${CONFIG.limits.durations.longBreak.max}åˆ†ã§è¨­å®šã—ã¦ãã ã•ã„` },
+      { value: longInterval, min: 2, max: 12, field: dom.settingsLongInterval, message: "é•·ã„ä¼‘æ†©ã®é–“éš”ã¯2ã€œ12å›ã®ç¯„å›²ã§è¨­å®šã—ã¦ãã ã•ã„" }
+    ];
+    for (const rule of constraints) {
+      if (!Number.isFinite(rule.value) || rule.value < rule.min || rule.value > rule.max) {
+        showNotification(rule.message, "error");
+        rule.field?.focus();
+        return;
+      }
+    }
+    const nextSettings = normalizeSettings({
+      ...state.settings,
+      workDuration,
+      shortBreakDuration: shortBreak,
+      longBreakDuration: longBreak,
+      longBreakInterval: longInterval,
+      notificationSound,
+      focusMode,
+      filterState
+    });
+    state.settings = nextSettings;
+    commitSettings();
+    if (!state.timer.isRunning) {
+      const activeMode = state.timer.mode === "idle" ? "work" : state.timer.mode;
+      syncDuration(activeMode);
+      if (!state.timer.isPaused) state.timer.remainingTime = state.timer.duration;
+      commitTimer();
+    }
+    populateSettingsForm();
+    dom.settingsDialog?.close("confirm");
+    showNotification("è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ", "success");
+  }
+
+  function toggleFocusMode() {
+    state.settings.focusMode = !state.settings.focusMode;
+    commitSettings();
+    showNotification(state.settings.focusMode ? "é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸ" : "é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸ", "info");
+  }
+
+  async function bulkDeleteCompleted(event) {
+    event?.preventDefault();
+    if (isFocusLocked()) return showNotification(ERRORS.E011, "warning");
+    if (state.ui.editingTaskId) return showNotification(ERRORS.E008, "warning");
+    const completedTasks = state.tasks.filter((task) => task.completed);
+    if (!completedTasks.length) {
+      showNotification("å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯ã¯ã‚ã‚Šã¾ã›ã‚“", "info");
+      return;
+    }
+    const confirmed = await confirmAction("å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯ã‚’ã™ã¹ã¦å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ");
+    if (!confirmed) return;
+    const completedIds = new Set(completedTasks.map((task) => task.id));
+    const remaining = state.tasks.filter((task) => !completedIds.has(task.id));
+    state.tasks.splice(0, state.tasks.length, ...remaining);
+    if (state.selectedTaskId && completedIds.has(state.selectedTaskId)) {
+      state.selectedTaskId = null;
+      if (!state.timer.isRunning) state.timer.currentTaskId = null;
+      persistSelection();
+    }
+    commitTasks();
+    showNotification("å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯ã‚’å‰Šé™¤ã—ã¾ã—ãŸ", "info");
+  }
+
+  function moveTask(taskId, direction) {
+    if (state.settings.filterState !== "all" || state.ui.searchTerm) {
+      showNotification("ä¸¦ã³æ›¿ãˆã¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ç„¡ã—ã®çŠ¶æ…‹ã§åˆ©ç”¨ã§ãã¾ã™", "warning");
+      return;
+    }
+    if (isFocusLocked()) {
+      showNotification(ERRORS.E011, "warning");
+      return;
+    }
+    const index = state.tasks.findIndex((task) => task.id === taskId);
+    if (index === -1) return;
+    const offset = direction === "up" ? -1 : 1;
+    const targetIndex = index + offset;
+    if (targetIndex < 0 || targetIndex >= state.tasks.length) return;
+    const [task] = state.tasks.splice(index, 1);
+    state.tasks.splice(targetIndex, 0, task);
+    commitTasks();
+  }
+
+  function exportData(event) {
+    event?.preventDefault();
+    const payload = {
+      version: 1,
+      exportedAt: nowISO(),
+      tasks: state.tasks,
+      timer: state.timer,
+      settings: state.settings,
+      today: state.today,
+      history: state.history,
+      selectedTaskId: state.selectedTaskId
+    };
+    const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
+    const url = URL.createObjectURL(blob);
+    const link = document.createElement("a");
+    link.href = url;
+    link.download = `pomotodo-export-${formatDateKey(new Date())}.json`;
+    link.click();
+    URL.revokeObjectURL(url);
+  }
+
+  function handleDataImport(event) {
+    const file = event.target?.files?.[0];
+    if (!file) return;
+    const reader = new FileReader();
+    reader.onload = () => {
+      try {
+        const data = JSON.parse(reader.result);
+        mergeImportedData(data);
+        showNotification("ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ", "success");
+      } catch (error) {
+        console.error("import failed", error);
+        showNotification("ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ", "error");
+      } finally {
+        event.target.value = "";
+      }
+    };
+    reader.onerror = () => {
+      showNotification("ã‚¤ãƒ³ãƒãƒ¼ãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ", "error");
+      event.target.value = "";
+    };
+    reader.readAsText(file);
+  }
+
+  function mergeImportedData(data) {
+    if (!data || typeof data !== "object") throw new Error("Invalid import payload");
+
+    let tasksMutated = false;
+    if (Array.isArray(data.tasks)) {
+      const importedTasks = data.tasks.map(normalizeTask).filter(Boolean);
+      if (importedTasks.length) {
+        const existingIds = new Set(state.tasks.map((task) => task.id));
+        const merged = state.tasks.map((task) => {
+          const replacementTask = importedTasks.find((item) => item.id === task.id);
+          return replacementTask ?? task;
+        });
+        importedTasks.forEach((task) => {
+          if (!existingIds.has(task.id)) merged.push(task);
+        });
+        state.tasks.splice(0, state.tasks.length, ...merged);
+        tasksMutated = true;
+        commitTasks();
+      }
+    }
+
+    if (data.settings) {
+      state.settings = normalizeSettings({ ...state.settings, ...data.settings });
+      commitSettings();
+    }
+
+    if (data.timer) {
+      state.timer = normalizeTimer({ ...state.timer, ...data.timer });
+      commitTimer();
+    }
+
+    if (data.today) {
+      const nextToday = normalizeToday(data.today);
+      if (nextToday) {
+        state.today = nextToday;
+        persistToday();
+        updateStatistics();
+      }
+    }
+
+    if (Array.isArray(data.history)) {
+      const historyByDate = new Map();
+      state.history.forEach((entry) => {
+        const normalized = normalizeHistoryEntry(entry);
+        if (normalized) historyByDate.set(normalized.date, normalized);
+      });
+      data.history.forEach((entry) => {
+        const normalized = normalizeHistoryEntry(entry);
+        if (!normalized) return;
+        const existing = historyByDate.get(normalized.date);
+        if (!existing) {
+          historyByDate.set(normalized.date, normalized);
+          return;
+        }
+        historyByDate.set(normalized.date, {
+          date: normalized.date,
+          pomodoros: Math.max(existing.pomodoros, normalized.pomodoros),
+          completedTasks: Math.max(existing.completedTasks, normalized.completedTasks),
+          streak: Math.max(existing.streak, normalized.streak)
+        });
+      });
+      state.history = Array.from(historyByDate.values()).sort((a, b) => a.date.localeCompare(b.date));
+      if (state.history.length > CONFIG.historyLimit) state.history = state.history.slice(-CONFIG.historyLimit);
+      persistHistory();
+    }
+
+    if (typeof data.selectedTaskId === "string") {
+      const exists = state.tasks.some((task) => task.id === data.selectedTaskId);
+      state.selectedTaskId = exists ? data.selectedTaskId : null;
+      if (!state.timer.isRunning) state.timer.currentTaskId = state.selectedTaskId;
+      persistSelection();
+      if (state.timer.currentTaskId !== (state.selectedTaskId ?? null)) commitTimer();
+    } else if (state.selectedTaskId && !state.tasks.some((task) => task.id === state.selectedTaskId)) {
+      state.selectedTaskId = null;
+      if (!state.timer.isRunning) state.timer.currentTaskId = null;
+      persistSelection();
+      commitTimer();
+    }
+
+    if (state.timer.currentTaskId && !state.tasks.some((task) => task.id === state.timer.currentTaskId)) {
+      state.timer.currentTaskId = null;
+      commitTimer();
+    }
+
+    if (tasksMutated) bus.emit("tasks:updated", state.tasks);
+  }
+
+
+  function showNotification(message, type = "info") {
+    if (!dom.notification) return;
+    dom.notification.textContent = message;
+    dom.notification.className = `notification ${type}`;
+    dom.notification.style.display = "block";
+    clearTimeout(dom.notification.timeoutId);
+    dom.notification.timeoutId = setTimeout(() => (dom.notification.style.display = "none"), 3000);
+  }
+
+  function playSound() {
+    const preference = state.settings.notificationSound || "beep";
+    if (preference === "silent") return;
+    const sequence = AUDIO_PROFILES[preference] ?? AUDIO_PROFILES.beep;
+    const AudioCtx = window.AudioContext || window.webkitAudioContext;
+    if (AudioCtx) {
+      try {
+        if (!audioContext) audioContext = new AudioCtx();
+        if (audioContext.state === "suspended") audioContext.resume().catch(() => {});
+        let cursor = audioContext.currentTime;
+        sequence.forEach((step) => {
+          if (step.gap) {
+            cursor += step.gap;
+            return;
+          }
+          const toneDuration = step.duration ?? 0.2;
+          const oscillator = audioContext.createOscillator();
+          oscillator.type = step.type || "sine";
+          oscillator.frequency.setValueAtTime(step.frequency || 440, cursor);
+          const gainNode = audioContext.createGain();
+          const gainValue = step.gain ?? 0.25;
+          gainNode.gain.setValueAtTime(gainValue, cursor);
+          if (step.decay) {
+            const decayTime = Math.max(toneDuration * step.decay, 0.05);
+            gainNode.gain.exponentialRampToValueAtTime(0.0001, cursor + decayTime);
+          } else {
+            gainNode.gain.setValueAtTime(gainValue, cursor + toneDuration);
+          }
+          oscillator.connect(gainNode);
+          gainNode.connect(audioContext.destination);
+          oscillator.start(cursor);
+          oscillator.stop(cursor + toneDuration);
+          const toneEnd = cursor + toneDuration;
+          setTimeout(() => {
+            try {
+              oscillator.disconnect();
+              gainNode.disconnect();
+            } catch (_) {}
+          }, Math.max((toneEnd - audioContext.currentTime + 0.2) * 1000, 0));
+          cursor = toneEnd;
+        });
+        return;
+      } catch (error) {
+        console.warn("audio context playback failed", error);
+      }
+    }
+    if (!fallbackAudio) fallbackAudio = new Audio(AUDIO_FALLBACK_SRC);
+    fallbackAudio.currentTime = 0;
+    fallbackAudio.play().catch(() => {});
+  }
+
+  function notify(message) {
+    if (!("Notification" in window)) return;
+    if (Notification.permission === "granted") new Notification("PomoTodo", { body: message, icon: "ğŸ…" });
+  }
+
+  function requestNotificationPermission() {
+    if (!("Notification" in window) || Notification.permission !== "default") return;
+    Notification.requestPermission().catch(() => {});
+  }
+
+  function confirmAction(message) {
+    if (!dom.confirmDialog) return Promise.resolve(window.confirm(message));
+    dom.confirmMessage.textContent = message;
+    dom.confirmDialog.showModal();
+    return new Promise((resolve) => {
+      const closeHandler = () => {
+        dom.confirmDialog.removeEventListener("close", closeHandler);
+        resolve(dom.confirmDialog.returnValue === "confirm");
+      };
+      dom.confirmDialog.addEventListener("close", closeHandler, { once: true });
+    });
+  }
+
+  function load(key, fallback) {
+    if (!storageAvailable()) return fallback;
+    try {
+      const raw = localStorage.getItem(key);
+      return raw ? JSON.parse(raw) : fallback;
+    } catch (error) {
+      console.warn("storage load failed", error);
+      showNotification(ERRORS.E006, "warning");
+      return fallback;
+    }
+  }
+
+  function save(key, value) {
+    if (!storageAvailable()) return;
+    try {
+      localStorage.setItem(key, JSON.stringify(value));
+    } catch (error) {
+      console.warn("storage save failed", error);
+      showNotification(error?.name === "QuotaExceededError" ? ERRORS.E005 : ERRORS.E006, "error");
+    }
+  }
+
+  function storageAvailable() {
+    try {
+      localStorage.setItem("pomotodo__test", "1");
+      localStorage.removeItem("pomotodo__test");
+      return true;
+    } catch {
+      showNotification(ERRORS.E006, "error");
+      return false;
+    }
+  }
+
+  function persistTasks() { save(CONFIG.storageKeys.tasks, state.tasks); }
+  function persistTimer() { save(CONFIG.storageKeys.timer, state.timer); }
+  function persistSettings() { save(CONFIG.storageKeys.settings, state.settings); }
+  function persistToday() { save(CONFIG.storageKeys.today, state.today); }
+  function persistSelection() { save(CONFIG.storageKeys.selection, state.selectedTaskId); }
+
+  function commitTasks() {
+    persistTasks();
+    bus.emit("tasks:updated", state.tasks);
+  }
+
+  function commitTimer() {
+    persistTimer();
+    bus.emit("timer:updated", state.timer);
+  }
+
+  function commitSettings() {
+    persistSettings();
+    bus.emit("settings:updated", state.settings);
+  }
+
+  function resumeFromPersisted() {
+    const remaining = Math.max(state.timer.duration - Math.floor((Date.now() - state.timer.startedAt) / 1000), 0);
+    state.timer.remainingTime = remaining;
+    commitTimer();
+    if (remaining <= 0) return completeSession();
+    timerId = setInterval(updateTimer, 1000);
+    dom.timerMode.parentElement?.classList.add("running");
+  }
+
+  function inferSelectedTask() {
+    const id = state.timer.currentTaskId;
+    return state.tasks.some((t) => t.id === id) ? id : null;
+  }
+
+  function ensureToday() {
+    const todayKey = formatDateKey(new Date());
+    if (state.today.date !== todayKey) {
+      if (state.today.pomodoros || state.today.completedTasks) {
+        state.history.push({ ...state.today });
+        if (state.history.length > CONFIG.historyLimit) state.history.splice(0, state.history.length - CONFIG.historyLimit);
+        persistHistory();
+      }
+      state.today = createToday();
+      persistToday();
+    }
+    return state.today;
+  }
+
+  function modeLabel(mode) {
+    if (mode === "work") return "ä½œæ¥­ä¸­";
+    if (mode === "shortBreak") return "ä¼‘æ†©ä¸­";
+    if (mode === "longBreak") return "é•·ã„ä¼‘æ†©ä¸­";
+    return "å¾…æ©Ÿä¸­";
+  }
+
+  function modeColor(mode) {
+    if (mode === "work") return "var(--primary-red)";
+    if (mode === "shortBreak") return "var(--primary-green)";
+    if (mode === "longBreak") return "var(--primary-blue)";
+    return "var(--text-secondary)";
+  }
+
+  function formatTime(seconds) {
+    const m = Math.floor(seconds / 60);
+    const s = Math.floor(seconds % 60);
+    return `${m.toString().padStart(2, "0")}:${s.toString().padStart(2, "0")}`;
+  }
+
+  function formatDateKey(date) {
+    return date.toISOString().slice(0, 10);
+  }
+
+  function createTimerState(initial = {}) {
+    const baseDuration = Number(initial.duration ?? DEFAULT_SETTINGS.workDuration * 60);
+    const startedAt = typeof initial.startedAt === "number" ? initial.startedAt : null;
+    return {
+      mode: initial.mode ?? "idle",
+      duration: baseDuration,
+      remainingTime: Number.isFinite(initial.remainingTime) ? Math.max(initial.remainingTime, 0) : baseDuration,
+      isRunning: Boolean(initial.isRunning),
+      isPaused: Boolean(initial.isPaused),
+      currentTaskId: initial.currentTaskId ?? null,
+      startedAt,
+      pomodoroCount: Number.isInteger(initial.pomodoroCount) ? Math.max(initial.pomodoroCount, 0) : 0,
+      sessionCounter: Number.isInteger(initial.sessionCounter) ? Math.max(initial.sessionCounter, 0) : 0
+    };
+  }
+
+  function createToday(initial = {}) {
+    return {
+      date: initial.date ?? formatDateKey(new Date()),
+      pomodoros: Number.isInteger(initial.pomodoros) ? Math.max(initial.pomodoros, 0) : 0,
+      completedTasks: Number.isInteger(initial.completedTasks) ? Math.max(initial.completedTasks, 0) : 0,
+      streak: Number.isInteger(initial.streak) ? Math.max(initial.streak, 0) : 0
+    };
+  }
+
+  function normalizeToday(raw) {
+    if (!raw || typeof raw !== "object") return null;
+    const draft = createToday({ ...raw, date: typeof raw.date === "string" ? raw.date : formatDateKey(new Date()) });
+    return draft;
+  }
+
+  function normalizeTimer(raw) {
+    const base = createTimerState(raw ?? {});
+    if (base.mode === "work") base.duration = clamp(base.duration, CONFIG.limits.durations.work.min * 60, CONFIG.limits.durations.work.max * 60);
+    if (base.mode === "shortBreak") base.duration = clamp(base.duration, CONFIG.limits.durations.shortBreak.min * 60, CONFIG.limits.durations.shortBreak.max * 60);
+    if (base.mode === "longBreak") base.duration = clamp(base.duration, CONFIG.limits.durations.longBreak.min * 60, CONFIG.limits.durations.longBreak.max * 60);
+    base.remainingTime = Math.min(Math.max(base.remainingTime, 0), base.duration);
+    return base;
+  }
+
+  function clamp(value, min, max) {
+    return Math.min(Math.max(value, min), max);
+  }
+
+  function generateTaskId() {
+    return `task_${Date.now()}_${Math.random().toString(16).slice(2)}`;
+  }
+
+  function nowISO() {
+    return new Date().toISOString();
+  }
+
+  function createTask({ title, estimatedPomodoros }) {
+    return {
+      id: generateTaskId(),
+      title,
+      completed: false,
+      estimatedPomodoros,
+      actualPomodoros: 0,
+      createdAt: nowISO(),
+      completedAt: null
+    };
+  }
+
+  function normalizeTask(raw) {
+    if (!raw) return null;
+    const title = String(raw.title ?? "").trim().slice(0, CONFIG.limits.titleMax);
+    if (!title) return null;
+    const estimated = clamp(Number(raw.estimatedPomodoros) || 1, CONFIG.limits.estimate.min, CONFIG.limits.estimate.max);
+    const actual = Math.max(Number(raw.actualPomodoros) || 0, 0);
+    const completed = Boolean(raw.completed);
+    const completedAt = completed ? raw.completedAt ?? nowISO() : null;
+    return {
+      id: raw.id ?? generateTaskId(),
+      title,
+      completed,
+      estimatedPomodoros: estimated,
+      actualPomodoros: clamp(actual, 0, 999),
+      createdAt: raw.createdAt ?? nowISO(),
+      completedAt
+    };
+  }
+
+  function normalizeSettings(raw) {
+    const draft = { ...raw };
+    draft.workDuration = clamp(Number(draft.workDuration) || DEFAULT_SETTINGS.workDuration, CONFIG.limits.durations.work.min, CONFIG.limits.durations.work.max);
+    draft.shortBreakDuration = clamp(Number(draft.shortBreakDuration) || DEFAULT_SETTINGS.shortBreakDuration, CONFIG.limits.durations.shortBreak.min, CONFIG.limits.durations.shortBreak.max);
+    draft.longBreakDuration = clamp(Number(draft.longBreakDuration) || DEFAULT_SETTINGS.longBreakDuration, CONFIG.limits.durations.longBreak.min, CONFIG.limits.durations.longBreak.max);
+    draft.longBreakInterval = clamp(Number(draft.longBreakInterval) || DEFAULT_SETTINGS.longBreakInterval, 2, 12);
+    draft.notificationSound = ["beep", "bell", "chime", "silent"].includes(draft.notificationSound) ? draft.notificationSound : DEFAULT_SETTINGS.notificationSound;
+    draft.focusMode = Boolean(draft.focusMode);
+    draft.filterState = ["all", "active", "completed"].includes(draft.filterState) ? draft.filterState : DEFAULT_SETTINGS.filterState;
+    return draft;
+  }
+
+  function normalizeHistoryEntry(raw) {
+    if (!raw) return null;
+    const date = typeof raw.date === "string" ? raw.date : null;
+    if (!date) return null;
+    return {
+      date,
+      pomodoros: Number.isInteger(raw.pomodoros) ? Math.max(raw.pomodoros, 0) : 0,
+      completedTasks: Number.isInteger(raw.completedTasks) ? Math.max(raw.completedTasks, 0) : 0,
+      streak: Number.isInteger(raw.streak) ? Math.max(raw.streak, 0) : 0
+    };
+  }
+
+  function persistHistory() {
+    save(CONFIG.storageKeys.history, state.history);
+    bus.emit("history:updated", state.history);
+  }
+
+  function createEventBus() {
+    const listeners = new Map();
+    return {
+      on(event, handler) {
+        if (!listeners.has(event)) listeners.set(event, new Set());
+        listeners.get(event).add(handler);
+      },
+      off(event, handler) {
+        listeners.get(event)?.delete(handler);
+      },
+      emit(event, payload) {
+        listeners.get(event)?.forEach((handler) => handler(payload));
+      }
+    };
+  }
+})();
diff --git a/index.html b/index.html
new file mode 100644
index 0000000..b8822ce
--- /dev/null
+++ b/index.html
@@ -0,0 +1,169 @@
+<!DOCTYPE html>
+<html lang="ja">
+<head>
+  <meta charset="utf-8" />
+  <meta name="viewport" content="width=device-width, initial-scale=1" />
+  <meta name="description" content="PomoTodoã¯ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã‚¿ã‚¤ãƒãƒ¼ã¨ã‚¿ã‚¹ã‚¯ç®¡ç†ã‚’çµ±åˆã—ãŸç”Ÿç”£æ€§å‘ä¸Šã‚¢ãƒ—ãƒªã§ã™ã€‚" />
+  <title>PomoTodo - ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã‚¿ã‚¤ãƒãƒ¼çµ±åˆå‹ã‚¿ã‚¹ã‚¯ç®¡ç†</title>
+  <link rel="stylesheet" href="style.css" />
+</head>
+<body>
+  <header class="app-header" role="banner">
+    <div class="branding">
+      <h1 class="app-title" aria-level="1">PomoTodo</h1>
+      <p class="app-subtitle">ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã‚¿ã‚¤ãƒãƒ¼çµ±åˆå‹ã‚¿ã‚¹ã‚¯ç®¡ç†</p>
+    </div>
+    <div class="today-stats" aria-live="polite">
+      <div class="stat-item" aria-label="ä»Šæ—¥ã®ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­æ•°"><span class="stat-label">Today</span><span class="stat-value" id="stat-today-pomodoros">ğŸ… 0</span></div>
+      <div class="stat-item" aria-label="å®Œäº†ã—ãŸã‚¿ã‚¹ã‚¯æ•°"><span class="stat-label">Tasks</span><span class="stat-value" id="stat-today-tasks">âœ“ 0/0</span></div>
+      <div class="stat-item" aria-label="åˆè¨ˆä½œæ¥­æ™‚é–“"><span class="stat-label">Time</span><span class="stat-value" id="stat-today-time">0h 0m</span></div>
+      <div class="stat-item" aria-label="é€£ç¶šãƒãƒ¢ãƒ‰ãƒ¼ãƒ­"><span class="stat-label">Streak</span><span class="stat-value" id="stat-streak">0</span></div>
+    </div>
+    <div class="header-actions" role="group" aria-label="ã‚¢ãƒ—ãƒªæ“ä½œ">
+      <button class="btn btn-secondary" type="button" id="toggle-focus-btn" aria-pressed="false">é›†ä¸­ãƒ¢ãƒ¼ãƒ‰: OFF</button>
+      <button class="btn btn-secondary" type="button" id="open-settings-btn">è¨­å®š</button>
+      <button class="btn btn-secondary" type="button" id="export-btn">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
+      <label class="btn btn-secondary file-input-label" for="import-input">
+        ã‚¤ãƒ³ãƒãƒ¼ãƒˆ
+        <input id="import-input" type="file" accept="application/json" />
+      </label>
+    </div>
+  </header>
+  <main class="app-main" role="main">
+    <section class="panel panel--tasks" aria-labelledby="tasks-heading">
+      <header class="panel-header">
+        <h2 id="tasks-heading">ã‚¿ã‚¹ã‚¯ãƒªã‚¹ãƒˆ</h2>
+        <p class="panel-description">ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã€ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã®è¦‹ç©ã‚‚ã‚Šã¨å®Ÿç¸¾ã‚’ç®¡ç†ã—ã¾ã™ã€‚</p>
+      </header>
+      <form class="task-form" id="task-form" aria-label="ã‚¿ã‚¹ã‚¯è¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ ">
+        <label class="form-group">
+          <span class="form-label">ã‚¿ã‚¹ã‚¯å</span>
+          <input id="task-title" name="taskTitle" type="text" maxlength="100" placeholder="æ–°ã—ã„ã‚¿ã‚¹ã‚¯" aria-required="true" autocomplete="off" />
+        </label>
+        <label class="form-group">
+          <span class="form-label">è¦‹ç©ã‚‚ã‚Š (ğŸ…)</span>
+          <input id="task-estimate" name="estimatedPomodoros" type="number" min="1" max="20" value="1" aria-required="true" />
+        </label>
+        <button class="btn btn-primary" type="submit" aria-label="ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ">è¿½åŠ </button>
+      </form>
+      <p class="form-error" id="task-form-error" role="alert" aria-live="assertive" hidden></p>
+      <div class="task-toolbar" role="toolbar" aria-label="ã‚¿ã‚¹ã‚¯æ“ä½œãƒ„ãƒ¼ãƒ«">
+        <label class="search-field">
+          <span class="visually-hidden">ã‚¿ã‚¹ã‚¯æ¤œç´¢</span>
+          <input type="search" id="task-search" placeholder="ã‚¿ã‚¹ã‚¯ã‚’æ¤œç´¢" autocomplete="off" />
+        </label>
+        <div class="toolbar-actions">
+          <button class="btn btn-secondary" type="button" id="sort-created-btn" data-sort="created">ä½œæˆé †</button>
+          <button class="btn btn-secondary" type="button" id="sort-estimate-btn" data-sort="estimate">è¦‹ç©é †</button>
+          <button class="btn btn-secondary" type="button" id="bulk-delete-btn">å®Œäº†ã‚¿ã‚¹ã‚¯å‰Šé™¤</button>
+        </div>
+      </div>
+      <div class="task-filters" role="group" aria-label="ã‚¿ã‚¹ã‚¯ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼">
+        <button class="filter-btn active" data-filter="all">å…¨ã¦</button>
+        <button class="filter-btn" data-filter="active">æœªå®Œäº†</button>
+        <button class="filter-btn" data-filter="completed">å®Œäº†æ¸ˆã¿</button>
+      </div>
+      <div class="empty-state" id="task-empty-state" aria-live="polite" hidden>ã‚¿ã‚¹ã‚¯ãŒã‚ã‚Šã¾ã›ã‚“ã€‚æœ€åˆã®ã‚¿ã‚¹ã‚¯ã‚’è¿½åŠ ã—ã¾ã—ã‚‡ã†ã€‚</div>
+      <ul class="task-list" id="task-list" role="list" aria-live="polite"></ul>
+    </section>
+    <section class="panel panel--timer" aria-labelledby="timer-heading">
+      <header class="panel-header">
+        <h2 id="timer-heading">ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­ã‚¿ã‚¤ãƒãƒ¼</h2>
+        <p class="panel-description">ã‚¿ã‚¹ã‚¯ã‚’é¸æŠã—ã¦é›†ä¸­ã‚¿ã‚¤ãƒãƒ¼ã‚’é–‹å§‹ã—ã¾ã—ã‚‡ã†ã€‚ä¼‘æ†©ã‚‚è‡ªå‹•ã§åˆ‡ã‚Šæ›¿ã‚ã‚Šã¾ã™ã€‚</p>
+      </header>
+      <div class="timer" role="timer" aria-live="assertive">
+        <div class="timer-mode" id="timer-mode">å¾…æ©Ÿä¸­</div>
+        <div class="timer-display" id="timer-display">25:00</div>
+        <div class="progress"><div class="progress-bar" id="progress-bar" role="presentation"></div></div>
+        <div class="current-task" id="current-task">é¸æŠä¸­: ãªã—</div>
+      </div>
+      <div class="timer-controls" role="group" aria-label="ã‚¿ã‚¤ãƒãƒ¼ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«">
+        <button class="btn btn-primary" id="start-btn" type="button">é–‹å§‹</button>
+        <button class="btn btn-secondary" id="pause-btn" type="button">ä¸€æ™‚åœæ­¢</button>
+        <button class="btn btn-secondary" id="reset-btn" type="button">ãƒªã‚»ãƒƒãƒˆ</button>
+        <button class="btn btn-danger" id="skip-btn" type="button">ã‚¹ã‚­ãƒƒãƒ—</button>
+      </div>
+      <section class="timer-stats" aria-labelledby="timer-stats-heading">
+        <h3 id="timer-stats-heading">ä»Šæ—¥ã®çµ±è¨ˆ</h3>
+        <ul class="stat-list">
+          <li class="stat-list-item"><span class="stat-list-label">ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­</span><span class="stat-list-value" id="stat-list-pomodoros">ğŸ… 0</span></li>
+          <li class="stat-list-item"><span class="stat-list-label">å®Œäº†ã‚¿ã‚¹ã‚¯</span><span class="stat-list-value" id="stat-list-tasks">âœ“ 0/0</span></li>
+          <li class="stat-list-item"><span class="stat-list-label">ä½œæ¥­æ™‚é–“</span><span class="stat-list-value" id="stat-list-time">0h 0m</span></li>
+        </ul>
+      </section>
+      <section class="weekly-insights" aria-labelledby="weekly-heading">
+        <h3 id="weekly-heading">éå»7æ—¥é–“ã®ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­</h3>
+        <div class="weekly-chart" id="weekly-chart" role="list" aria-live="polite"></div>
+      </section>
+    </section>
+  </main>
+  <div class="notification" id="notification" role="alert" aria-live="polite"></div>
+  <dialog class="confirm-dialog" id="confirm-dialog" aria-modal="true">
+    <form method="dialog" class="confirm-dialog__form">
+      <p class="confirm-dialog__message" id="confirm-message">ã“ã®æ“ä½œã‚’å®Ÿè¡Œã—ã¾ã™ã‹ï¼Ÿ</p>
+      <div class="confirm-dialog__actions">
+        <button value="cancel" class="btn btn-secondary">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
+        <button value="confirm" class="btn btn-danger">å®Ÿè¡Œ</button>
+      </div>
+    </form>
+  </dialog>
+  <dialog class="settings-dialog" id="settings-dialog" aria-modal="true">
+    <form method="dialog" class="settings-form" id="settings-form">
+      <header class="settings-header">
+        <h2 class="settings-title">è¨­å®š</h2>
+        <p class="settings-description">ã‚¿ã‚¤ãƒãƒ¼æ™‚é–“ã‚„é€šçŸ¥éŸ³ã€é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ãªã©ã‚’ã‚«ã‚¹ã‚¿ãƒã‚¤ã‚ºã—ã¾ã™ã€‚</p>
+      </header>
+      <div class="settings-grid">
+        <label class="settings-field">
+          <span>ä½œæ¥­æ™‚é–“ (åˆ†)</span>
+          <input type="number" id="settings-work-duration" min="1" max="60" required />
+        </label>
+        <label class="settings-field">
+          <span>çŸ­ã„ä¼‘æ†© (åˆ†)</span>
+          <input type="number" id="settings-short-break" min="1" max="30" required />
+        </label>
+        <label class="settings-field">
+          <span>é•·ã„ä¼‘æ†© (åˆ†)</span>
+          <input type="number" id="settings-long-break" min="5" max="60" required />
+        </label>
+        <label class="settings-field">
+          <span>é•·ã„ä¼‘æ†©ã®é–“éš” (ãƒãƒ¢ãƒ‰ãƒ¼ãƒ­)</span>
+          <input type="number" id="settings-long-interval" min="2" max="12" required />
+        </label>
+        <label class="settings-field">
+          <span>é€šçŸ¥éŸ³</span>
+          <select id="settings-sound">
+            <option value="beep">ãƒ“ãƒ¼ãƒ—</option>
+            <option value="bell">ãƒ™ãƒ«</option>
+            <option value="chime">ãƒãƒ£ã‚¤ãƒ </option>
+            <option value="silent">ã‚µã‚¤ãƒ¬ãƒ³ãƒˆ</option>
+          </select>
+        </label>
+        <label class="settings-field settings-toggle">
+          <input type="checkbox" id="settings-focus-mode" />
+          <span>é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ã‚’æœ‰åŠ¹ã«ã™ã‚‹</span>
+        </label>
+        <label class="settings-field">
+          <span>ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼</span>
+          <select id="settings-filter-default">
+            <option value="all">å…¨ã¦</option>
+            <option value="active">æœªå®Œäº†</option>
+            <option value="completed">å®Œäº†æ¸ˆã¿</option>
+          </select>
+        </label>
+      </div>
+      <footer class="settings-actions">
+        <button type="button" class="btn btn-secondary" id="settings-reset-btn">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™</button>
+        <div class="settings-actions__submit">
+          <button value="cancel" class="btn btn-secondary">ã‚­ãƒ£ãƒ³ã‚»ãƒ«</button>
+          <button value="confirm" class="btn btn-primary" id="settings-save-btn">ä¿å­˜</button>
+        </div>
+      </footer>
+    </form>
+  </dialog>
+  <div class="focus-overlay" id="focus-overlay" aria-hidden="true">
+    <p>é›†ä¸­ãƒ¢ãƒ¼ãƒ‰ãŒæœ‰åŠ¹ã§ã™ã€‚ã‚¿ã‚¤ãƒãƒ¼çµ‚äº†ã¾ã§ä»–ã®æ“ä½œã¯åˆ¶é™ã•ã‚Œã¾ã™ã€‚</p>
+  </div>
+  <script src="app.js" defer></script>
+</body>
+</html>
diff --git a/style.css b/style.css
new file mode 100644
index 0000000..b6ca907
--- /dev/null
+++ b/style.css
@@ -0,0 +1,126 @@
+:root{color-scheme:light dark;--primary-red:#ff5a5f;--primary-green:#2ecc71;--primary-blue:#4f46e5;--bg-main:#f4f6fb;--bg-surface:#fff;--bg-hover:rgba(79,70,229,.12);--bg-overlay:rgba(15,23,42,.55);--text-primary:#111827;--text-secondary:#4b5563;--border:rgba(15,23,42,.12);--success:#22c55e;--warning:#f59e0b;--error:#ef4444;--radius-sm:8px;--radius-md:16px;--radius-lg:22px;--shadow-sm:0 6px 18px rgba(15,23,42,.08);--shadow-md:0 18px 36px rgba(26,35,64,.16);--timer-size:clamp(3rem,5vw,4.25rem)}
+*,:before,:after{box-sizing:border-box}
+body,h1,h2,h3,h4,p,ul,li,button,input{margin:0;padding:0;font:inherit}
+body{min-height:100vh;font-family:-apple-system,BlinkMacSystemFont,"Segoe UI","Hiragino Sans","Noto Sans JP",sans-serif;background:linear-gradient(135deg,rgba(79,70,229,.09),rgba(34,197,94,.08));color:var(--text-primary);line-height:1.6;padding:24px;display:flex;flex-direction:column;gap:24px}
+.visually-hidden{position:absolute!important;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0 0 0 0);white-space:nowrap;border:0}
+input,button{border:none}
+button{cursor:pointer;transition:transform .18s ease,box-shadow .18s ease,background .18s ease}
+button:disabled{cursor:not-allowed;opacity:.55}
+input{width:100%;padding:12px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--bg-surface);transition:border .18s ease,box-shadow .18s ease}
+input:focus{outline:none;border-color:var(--primary-blue);box-shadow:0 0 0 3px rgba(79,70,229,.18)}
+.app-header{display:grid;grid-template-columns:minmax(0,1fr) auto auto;align-items:center;padding:24px;border-radius:var(--radius-lg);background:var(--bg-surface);box-shadow:var(--shadow-sm);gap:24px}
+.branding{display:flex;flex-direction:column;gap:4px}
+.app-title{font-size:2rem;font-weight:700}
+.app-subtitle{color:var(--text-secondary);font-size:.95rem}
+.today-stats{display:flex;gap:18px;flex-wrap:wrap;justify-content:flex-end}
+.stat-item{display:flex;flex-direction:column;align-items:flex-end;min-width:96px}
+.stat-label{font-size:.68rem;text-transform:uppercase;letter-spacing:.08em;color:var(--text-secondary)}
+.stat-value{font-size:1.1rem;font-weight:600}
+.header-actions{display:flex;gap:12px;flex-wrap:wrap;justify-content:flex-end}
+.file-input-label{position:relative;overflow:hidden}
+.file-input-label input{position:absolute;inset:0;opacity:0;cursor:pointer}
+.app-main{display:grid;grid-template-columns:minmax(0,1fr) minmax(0,1.15fr);gap:24px;width:100%;max-width:1180px;margin:0 auto}
+.panel{background:var(--bg-surface);border-radius:var(--radius-lg);box-shadow:var(--shadow-sm);padding:24px;display:flex;flex-direction:column;gap:18px}
+.panel-header h2{font-size:1.35rem;font-weight:700}
+.panel-description{color:var(--text-secondary);font-size:.9rem}
+.task-form{display:grid;grid-template-columns:1.4fr .6fr auto;gap:12px;align-items:end}
+.form-label{font-size:.72rem;text-transform:uppercase;color:var(--text-secondary);font-weight:600;margin-bottom:6px}
+.form-error{margin-top:-4px;font-size:.85rem;color:var(--error);min-height:1.2em}
+.task-toolbar{display:flex;flex-wrap:wrap;gap:12px;align-items:center;justify-content:space-between}
+.search-field{flex:1 0 220px;position:relative}
+.search-field input{width:100%;padding-left:40px;background:var(--bg-surface) url('data:image/svg+xml,%3Csvg width="16" height="16" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"%3E%3Cpath d="M21 21L16.65 16.65M18 10.5C18 14.6421 14.6421 18 10.5 18C6.35786 18 3 14.6421 3 10.5C3 6.35786 6.35786 3 10.5 3C14.6421 3 18 6.35786 18 10.5Z" stroke="%237f8c8d" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/%3E%3C/svg%3E') no-repeat 12px center;background-size:18px}
+.toolbar-actions{display:flex;gap:10px;flex-wrap:wrap}
+.btn{display:inline-flex;align-items:center;justify-content:center;gap:6px;padding:10px 16px;border-radius:var(--radius-sm);font-size:.98rem;font-weight:600}
+.btn-primary{background:var(--primary-blue);color:#fff;box-shadow:0 10px 24px rgba(79,70,229,.25)}
+.btn-primary:hover:not(:disabled){transform:translateY(-1px);box-shadow:0 16px 32px rgba(79,70,229,.32)}
+.btn-secondary{background:rgba(79,70,229,.1);color:var(--primary-blue)}
+.btn-secondary:hover:not(:disabled){background:rgba(79,70,229,.16)}
+.btn-danger{background:var(--error);color:#fff;box-shadow:0 12px 28px rgba(239,68,68,.28)}
+.btn-danger:hover:not(:disabled){transform:translateY(-1px);box-shadow:0 18px 36px rgba(239,68,68,.36)}
+.task-filters{display:flex;gap:10px;flex-wrap:wrap}
+.filter-btn{padding:7px 16px;border-radius:24px;font-size:.82rem;background:rgba(15,23,42,.06);color:var(--text-secondary)}
+.filter-btn.active,.filter-btn:hover{background:var(--bg-hover);color:var(--primary-blue)}
+.empty-state{padding:16px;border-radius:var(--radius-md);background:rgba(79,70,229,.08);color:var(--text-secondary);text-align:center}
+.task-list{display:flex;flex-direction:column;gap:12px;list-style:none}
+.task-item{display:flex;align-items:center;gap:14px;padding:16px;background:rgba(241,243,255,.9);border-radius:var(--radius-md);border:1px solid transparent;transition:transform .2s ease,border .2s ease,box-shadow .2s ease}
+.task-item:hover{transform:translateX(4px);box-shadow:var(--shadow-sm)}
+.task-item.selected{border-color:var(--primary-blue);background:rgba(79,70,229,.12)}
+.task-item.completed{opacity:.65}
+.task-item.completed .task-title-text{text-decoration:line-through}
+.task-item.editing{background:rgba(79,70,229,.16);border-color:var(--primary-blue);flex-direction:column;align-items:stretch;gap:12px}
+.task-content{flex:1;display:flex;flex-direction:column;gap:6px}
+.task-title-text{font-weight:600}
+.task-meta{display:flex;gap:12px;font-size:.82rem;color:var(--text-secondary)}
+.task-meta-summary{font-weight:600}
+.task-meta-summary--in-progress{color:var(--primary-blue)}
+.task-meta-summary--met{color:var(--primary-green)}
+.task-meta-summary--over{color:var(--primary-red)}
+.task-progress{flex:1 0 100%;height:6px;border-radius:999px;background:rgba(15,23,42,.12);overflow:hidden;position:relative;margin-top:6px}
+.task-progress__fill{height:100%;border-radius:inherit;background:var(--primary-blue);transition:width .3s ease}
+.task-progress--not-started .task-progress__fill{background:rgba(15,23,42,.22)}
+.task-progress--met .task-progress__fill{background:var(--primary-green)}
+.task-progress--over .task-progress__fill{background:var(--primary-red)}
+.task-actions{display:flex;gap:8px}
+.task-actions button{width:32px;height:32px;border-radius:50%;display:grid;place-items:center;background:rgba(15,23,42,.08);color:var(--text-secondary)}
+.task-actions button:hover{background:var(--bg-hover);color:var(--primary-blue)}
+.task-edit-form{display:flex;flex-wrap:wrap;gap:12px;align-items:center;width:100%}
+.task-edit-input{flex:1 0 220px;padding:12px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--bg-surface);font-weight:600}
+.task-edit-input:focus{outline:none;border-color:var(--primary-blue);box-shadow:0 0 0 3px rgba(79,70,229,.18)}
+.task-edit-meta{font-size:.85rem;color:var(--text-secondary)}
+.task-edit-actions{display:flex;gap:10px}
+.timer{display:flex;flex-direction:column;gap:14px;align-items:center;text-align:center}
+.timer-mode{font-size:1.1rem;font-weight:600;color:var(--primary-red)}
+.timer-display{font-size:var(--timer-size);font-weight:700;letter-spacing:.08em}
+.progress{width:100%;height:8px;border-radius:999px;background:rgba(15,23,42,.09);overflow:hidden}
+.progress-bar{height:100%;width:0;border-radius:inherit;background:linear-gradient(135deg,var(--primary-blue),var(--primary-green));transition:width .28s ease}
+.current-task{font-size:.85rem;color:var(--text-secondary)}
+.timer-controls{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;width:100%}
+.timer-stats{background:rgba(79,70,229,.08);border-radius:var(--radius-md);padding:16px}
+.timer-stats h3{font-size:1rem;font-weight:600;margin-bottom:10px}
+.stat-list{list-style:none;display:flex;flex-direction:column;gap:8px;font-size:.9rem}
+.stat-list-item{display:flex;justify-content:space-between;align-items:center}
+.stat-list-label{color:var(--text-secondary)}
+.stat-list-value{font-weight:600}
+.weekly-insights{background:rgba(15,23,42,.05);border-radius:var(--radius-md);padding:16px;display:flex;flex-direction:column;gap:12px}
+.weekly-insights h3{font-size:1rem;font-weight:600}
+.weekly-chart{display:flex;gap:12px;align-items:flex-end;min-height:120px}
+.weekly-chart__bar{flex:1;display:flex;flex-direction:column;align-items:center;gap:6px}
+.weekly-chart__bar-value{font-size:.82rem;font-weight:600}
+.weekly-chart__bar-track{width:100%;border-radius:12px;background:rgba(79,70,229,.18);position:relative;overflow:hidden}
+.weekly-chart__bar-fill{position:absolute;bottom:0;left:0;right:0;border-radius:inherit;background:linear-gradient(135deg,var(--primary-blue),var(--primary-green));transition:height .3s ease}
+.weekly-chart__bar-label{font-size:.75rem;color:var(--text-secondary)}
+.weekly-chart__placeholder{width:100%;text-align:center;color:var(--text-secondary);font-size:.85rem;padding:24px 12px;border-radius:var(--radius-md);background:rgba(79,70,229,.08)}
+.notification{position:fixed;right:24px;bottom:24px;min-width:240px;padding:15px 18px;border-radius:var(--radius-md);background:var(--bg-surface);color:var(--text-primary);box-shadow:var(--shadow-md);display:none;z-index:30}
+.notification.success{border-left:6px solid var(--success)}
+.notification.error{border-left:6px solid var(--error)}
+.notification.warning{border-left:6px solid var(--warning)}
+.notification.info{border-left:6px solid var(--primary-blue)}
+.confirm-dialog{border:none;border-radius:var(--radius-lg);padding:22px;background:var(--bg-surface);box-shadow:var(--shadow-md);width:min(360px,92vw)}
+.confirm-dialog::backdrop{background:var(--bg-overlay)}
+.confirm-dialog__form{display:flex;flex-direction:column;gap:18px}
+.confirm-dialog__actions{display:flex;justify-content:flex-end;gap:12px}
+.task-item.removing{animation:fadeOut .26s ease forwards}
+.task-item.new{animation:fadeIn .26s ease}
+.timer.running .timer-display{animation:pulse 2s ease-in-out infinite}
+@keyframes fadeOut{to{opacity:0;transform:translateX(-16px)}}
+@keyframes fadeIn{from{opacity:0;transform:translateY(-6px)}to{opacity:1;transform:translateY(0)}}
+@keyframes pulse{0%,100%{transform:scale(1)}50%{transform:scale(1.05)}}
+.settings-dialog{border:none;border-radius:var(--radius-lg);padding:0;background:var(--bg-surface);box-shadow:var(--shadow-md);width:min(640px,94vw)}
+.settings-dialog::backdrop{background:var(--bg-overlay)}
+.settings-form{display:flex;flex-direction:column;gap:20px;padding:24px}
+.settings-header{display:flex;flex-direction:column;gap:6px}
+.settings-title{font-size:1.4rem;font-weight:700}
+.settings-description{color:var(--text-secondary);font-size:.92rem}
+.settings-grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(240px,1fr));gap:16px}
+.settings-field{display:flex;flex-direction:column;gap:8px;font-size:.92rem}
+.settings-field input,.settings-field select{width:100%;padding:10px 12px;border:1px solid var(--border);border-radius:var(--radius-sm);background:var(--bg-main)}
+.settings-field input:focus,.settings-field select:focus{outline:none;border-color:var(--primary-blue);box-shadow:0 0 0 3px rgba(79,70,229,.18)}
+.settings-toggle{flex-direction:row;align-items:center;gap:10px}
+.settings-actions{display:flex;justify-content:space-between;align-items:center;gap:12px;margin-top:8px}
+.settings-actions__submit{display:flex;gap:12px}
+.focus-overlay{position:fixed;inset:0;background:rgba(15,23,42,.55);display:none;align-items:center;justify-content:center;text-align:center;padding:32px;color:#fff;z-index:40}
+.focus-overlay.active{display:flex}
+.focus-overlay p{font-size:1.1rem;max-width:420px}
+@media (max-width:1024px){.app-main{grid-template-columns:1fr}.panel--timer{order:-1}.app-header{grid-template-columns:1fr;gap:18px}.header-actions{justify-content:flex-start}}
+@media (max-width:768px){body{padding:18px}.app-header{grid-template-columns:1fr;align-items:flex-start}.today-stats{width:100%;justify-content:space-between}.header-actions{width:100%;justify-content:flex-start}.task-form{grid-template-columns:1fr}.task-toolbar{flex-direction:column;align-items:stretch}.toolbar-actions{width:100%;justify-content:flex-start}.timer-controls{grid-template-columns:repeat(2,minmax(0,1fr))}}
+@media (prefers-color-scheme:dark){:root{--bg-main:#0f172a;--bg-surface:#111a2c;--bg-hover:rgba(79,70,229,.22);--text-primary:#f8fafc;--text-secondary:#cbd5f5;--border:rgba(148,163,184,.3)}body{background:linear-gradient(135deg,rgba(79,70,229,.24),rgba(34,197,94,.22))}.task-item{background:rgba(30,41,59,.78)}.timer-stats{background:rgba(79,70,229,.24)}.filter-btn{background:rgba(148,163,184,.12)}.notification{background:rgba(17,24,39,.92)}}
```

## ğŸ” Automated Analysis

### Changes Summary

- **Lines Added**: 1713
- **Lines Removed**: 3
- **Net Change**: 1710 lines

### Potential Issues Detected

âœ… **No major issues detected** by automated pattern matching.

This does not guarantee the code is problem-free. Manual review is still recommended.

### ğŸ“ Code Quality Suggestions

- **Security**: Review all changes for security implications, especially authentication and data handling
- **Error Handling**: Ensure proper error handling and recovery mechanisms are implemented
- **Testing**: Add unit tests for new functionality and edge cases
- **Documentation**: Update relevant documentation, docstrings, and comments
- **Style Guide**: Follow project-specific code style and formatting guidelines
- **Performance**: Consider performance implications of changes, especially in loops and database queries
- **Logging**: Use structured logging with appropriate log levels (DEBUG, INFO, WARNING, ERROR)

## ğŸ¤– AI-Enhanced Analysis (gemini)

Loaded cached credentials.
Attempt 1 failed with status 429. Retrying with backoff... GaxiosError: [{
  "error": {
    "code": 429,
    "message": "Resource exhausted. Please try again later. Please refer to https://cloud.google.com/vertex-ai/generative-ai/docs/error-code-429 for more details.",
    "errors": [
      {
        "message": "Resource exhausted. Please try again later. Please refer to https://cloud.google.com/vertex-ai/generative-ai/docs/error-code-429 for more details.",
        "domain": "global",
        "reason": "rateLimitExceeded"
      }
    ],
    "status": "RESOURCE_EXHAUSTED"
  }
}
]
    at Gaxios._request (/home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/gaxios/build/src/gaxios.js:142:23)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async OAuth2Client.requestAsync (/home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/google-auth-library/build/src/auth/oauth2client.js:429:18)
    at async CodeAssistServer.requestStreamingPost (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/code_assist/server.js:95:21)
    at async CodeAssistServer.generateContentStream (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/code_assist/server.js:25:23)
    at async LoggingContentGenerator.generateContentStream (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/loggingContentGenerator.js:57:22)
    at async retryWithBackoff (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/utils/retry.js:75:28)
    at async GeminiChat.makeApiCallAndProcessStream (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/geminiChat.js:267:32)
    at async file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/geminiChat.js:219:40
    at async Turn.run (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/turn.js:64:30) {
  config: {
    url: 'https://cloudcode-pa.googleapis.com/v1internal:streamGenerateContent?alt=sse',
    method: 'POST',
    params: { alt: 'sse' },
    headers: {
      'Content-Type': 'application/json',
      'User-Agent': 'GeminiCLI/v22.18.0 (linux; x64) google-api-nodejs-client/9.15.1',
      Authorization: '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.',
      'x-goog-api-client': 'gl-node/22.18.0'
    },
    responseType: 'stream',
    body: '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.',
    signal: AbortSignal { aborted: false },
    paramsSerializer: [Function: paramsSerializer],
    validateStatus: [Function: validateStatus],
    errorRedactor: [Function: defaultErrorRedactor]
  },
  response: {
    config: {
      url: 'https://cloudcode-pa.googleapis.com/v1internal:streamGenerateContent?alt=sse',
      method: 'POST',
      params: [Object],
      headers: [Object],
      responseType: 'stream',
      body: '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.',
      signal: [AbortSignal],
      paramsSerializer: [Function: paramsSerializer],
      validateStatus: [Function: validateStatus],
      errorRedactor: [Function: defaultErrorRedactor]
    },
    data: '[{\n' +
      '  "error": {\n' +
      '    "code": 429,\n' +
      '    "message": "Resource exhausted. Please try again later. Please refer to https://cloud.google.com/vertex-ai/generative-ai/docs/error-code-429 for more details.",\n' +
      '    "errors": [\n' +
      '      {\n' +
      '        "message": "Resource exhausted. Please try again later. Please refer to https://cloud.google.com/vertex-ai/generative-ai/docs/error-code-429 for more details.",\n' +
      '        "domain": "global",\n' +
      '        "reason": "rateLimitExceeded"\n' +
      '      }\n' +
      '    ],\n' +
      '    "status": "RESOURCE_EXHAUSTED"\n' +
      '  }\n' +
      '}\n' +
      ']',
    headers: {
      'alt-svc': 'h3=":443"; ma=2592000,h3-29=":443"; ma=2592000',
      'content-length': '514',
      'content-type': 'application/json; charset=UTF-8',
      date: 'Mon, 27 Oct 2025 13:41:30 GMT',
      server: 'ESF',
      'server-timing': 'gfet4t7; dur=1120',
      vary: 'Origin, X-Origin, Referer',
      'x-cloudaicompanion-trace-id': '36c78c5bcab264bd',
      'x-content-type-options': 'nosniff',
      'x-frame-options': 'SAMEORIGIN',
      'x-xss-protection': '0'
    },
    status: 429,
    statusText: 'Too Many Requests',
    request: {
      responseURL: 'https://cloudcode-pa.googleapis.com/v1internal:streamGenerateContent?alt=sse'
    }
  },
  error: undefined,
  status: 429,
  [Symbol(gaxios-gaxios-error)]: '6.7.1'
}
Fallback to Flash model failed: GaxiosError: [{
  "error": {
    "code": 429,
    "message": "Resource has been exhausted (e.g. check quota).",
    "errors": [
      {
        "message": "Resource has been exhausted (e.g. check quota).",
        "domain": "global",
        "reason": "rateLimitExceeded"
      }
    ],
    "status": "RESOURCE_EXHAUSTED"
  }
}
]
    at Gaxios._request (/home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/gaxios/build/src/gaxios.js:142:23)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async OAuth2Client.requestAsync (/home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/google-auth-library/build/src/auth/oauth2client.js:429:18)
    at async CodeAssistServer.requestStreamingPost (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/code_assist/server.js:95:21)
    at async CodeAssistServer.generateContentStream (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/code_assist/server.js:25:23)
    at async LoggingContentGenerator.generateContentStream (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/loggingContentGenerator.js:57:22)
    at async retryWithBackoff (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/utils/retry.js:75:28)
    at async GeminiChat.makeApiCallAndProcessStream (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/geminiChat.js:267:32)
    at async file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/geminiChat.js:219:40
    at async Turn.run (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/turn.js:64:30) {
  config: {
    url: 'https://cloudcode-pa.googleapis.com/v1internal:streamGenerateContent?alt=sse',
    method: 'POST',
    params: { alt: 'sse' },
    headers: {
      'Content-Type': 'application/json',
      'User-Agent': 'GeminiCLI/v22.18.0 (linux; x64) google-api-nodejs-client/9.15.1',
      Authorization: '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.',
      'x-goog-api-client': 'gl-node/22.18.0'
    },
    responseType: 'stream',
    body: '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.',
    signal: AbortSignal { aborted: false },
    paramsSerializer: [Function: paramsSerializer],
    validateStatus: [Function: validateStatus],
    errorRedactor: [Function: defaultErrorRedactor]
  },
  response: {
    config: {
      url: 'https://cloudcode-pa.googleapis.com/v1internal:streamGenerateContent?alt=sse',
      method: 'POST',
      params: [Object],
      headers: [Object],
      responseType: 'stream',
      body: '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.',
      signal: [AbortSignal],
      paramsSerializer: [Function: paramsSerializer],
      validateStatus: [Function: validateStatus],
      errorRedactor: [Function: defaultErrorRedactor]
    },
    data: '[{\n' +
      '  "error": {\n' +
      '    "code": 429,\n' +
      '    "message": "Resource has been exhausted (e.g. check quota).",\n' +
      '    "errors": [\n' +
      '      {\n' +
      '        "message": "Resource has been exhausted (e.g. check quota).",\n' +
      '        "domain": "global",\n' +
      '        "reason": "rateLimitExceeded"\n' +
      '      }\n' +
      '    ],\n' +
      '    "status": "RESOURCE_EXHAUSTED"\n' +
      '  }\n' +
      '}\n' +
      ']',
    headers: {
      'alt-svc': 'h3=":443"; ma=2592000,h3-29=":443"; ma=2592000',
      'content-length': '316',
      'content-type': 'application/json; charset=UTF-8',
      date: 'Mon, 27 Oct 2025 13:41:37 GMT',
      server: 'ESF',
      'server-timing': 'gfet4t7; dur=733',
      vary: 'Origin, X-Origin, Referer',
      'x-cloudaicompanion-trace-id': '1ed7da84a063a8cf',
      'x-content-type-options': 'nosniff',
      'x-frame-options': 'SAMEORIGIN',
      'x-xss-protection': '0'
    },
    status: 429,
    statusText: 'Too Many Requests',
    request: {
      responseURL: 'https://cloudcode-pa.googleapis.com/v1internal:streamGenerateContent?alt=sse'
    }
  },
  error: undefined,
  status: 429,
  [Symbol(gaxios-gaxios-error)]: '6.7.1'
}
Attempt 2 failed with status 429. Retrying with backoff... GaxiosError: [{
  "error": {
    "code": 429,
    "message": "Resource has been exhausted (e.g. check quota).",
    "errors": [
      {
        "message": "Resource has been exhausted (e.g. check quota).",
        "domain": "global",
        "reason": "rateLimitExceeded"
      }
    ],
    "status": "RESOURCE_EXHAUSTED"
  }
}
]
    at Gaxios._request (/home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/gaxios/build/src/gaxios.js:142:23)
    at process.processTicksAndRejections (node:internal/process/task_queues:105:5)
    at async OAuth2Client.requestAsync (/home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/google-auth-library/build/src/auth/oauth2client.js:429:18)
    at async CodeAssistServer.requestStreamingPost (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/code_assist/server.js:95:21)
    at async CodeAssistServer.generateContentStream (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/code_assist/server.js:25:23)
    at async LoggingContentGenerator.generateContentStream (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/loggingContentGenerator.js:57:22)
    at async retryWithBackoff (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/utils/retry.js:75:28)
    at async GeminiChat.makeApiCallAndProcessStream (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/geminiChat.js:267:32)
    at async file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/geminiChat.js:219:40
    at async Turn.run (file:///home/ryu/.nvm/versions/node/v22.18.0/lib/node_modules/@google/gemini-cli/node_modules/@google/gemini-cli-core/dist/src/core/turn.js:64:30) {
  config: {
    url: 'https://cloudcode-pa.googleapis.com/v1internal:streamGenerateContent?alt=sse',
    method: 'POST',
    params: { alt: 'sse' },
    headers: {
      'Content-Type': 'application/json',
      'User-Agent': 'GeminiCLI/v22.18.0 (linux; x64) google-api-nodejs-client/9.15.1',
      Authorization: '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.',
      'x-goog-api-client': 'gl-node/22.18.0'
    },
    responseType: 'stream',
    body: '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.',
    signal: AbortSignal { aborted: false },
    paramsSerializer: [Function: paramsSerializer],
    validateStatus: [Function: validateStatus],
    errorRedactor: [Function: defaultErrorRedactor]
  },
  response: {
    config: {
      url: 'https://cloudcode-pa.googleapis.com/v1internal:streamGenerateContent?alt=sse',
      method: 'POST',
      params: [Object],
      headers: [Object],
      responseType: 'stream',
      body: '<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.',
      signal: [AbortSignal],
      paramsSerializer: [Function: paramsSerializer],
      validateStatus: [Function: validateStatus],
      errorRedactor: [Function: defaultErrorRedactor]
    },
    data: '[{\n' +
      '  "error": {\n' +
      '    "code": 429,\n' +
      '    "message": "Resource has been exhausted (e.g. check quota).",\n' +
      '    "errors": [\n' +
      '      {\n' +
      '        "message": "Resource has been exhausted (e.g. check quota).",\n' +
      '        "domain": "global",\n' +
      '        "reason": "rateLimitExceeded"\n' +
      '      }\n' +
      '    ],\n' +
      '    "status": "RESOURCE_EXHAUSTED"\n' +
      '  }\n' +
      '}\n' +
      ']',
    headers: {
      'alt-svc': 'h3=":443"; ma=2592000,h3-29=":443"; ma=2592000',
      'content-length': '316',
      'content-type': 'application/json; charset=UTF-8',
      date: 'Mon, 27 Oct 2025 13:41:37 GMT',
      server: 'ESF',
      'server-timing': 'gfet4t7; dur=733',
      vary: 'Origin, X-Origin, Referer',
      'x-cloudaicompanion-trace-id': '1ed7da84a063a8cf',
      'x-content-type-options': 'nosniff',
      'x-frame-options': 'SAMEORIGIN',
      'x-xss-protection': '0'
    },
    status: 429,
    statusText: 'Too Many Requests',
    request: {
      responseURL: 'https://cloudcode-pa.googleapis.com/v1internal:streamGenerateContent?alt=sse'
    }
  },
  error: undefined,
  status: 429,
  [Symbol(gaxios-gaxios-error)]: '6.7.1'
}
Of course. Here is an analysis of the provided code changes.

### 1. Security Vulnerabilities

*   **Cross-Site Scripting (XSS):** The application loads task data and renders it. If task titles (`task.title`) are rendered into the DOM using `innerHTML`, and the title contains malicious HTML (e.g., `<script>alert('XSS')</script>`), it can lead to a security vulnerability. All user-provided content must be sanitized before being rendered.
*   **Data Integrity:** Data is loaded directly from `localStorage` (`load(...)`). Since `localStorage` can be easily modified by the user or other scripts on the same origin, the data should be treated as untrusted. The `normalize*` functions are a good defense, but they must be very robust. They need to validate data types, lengths, and value ranges for every property of every object loaded. For example, `settings.workDuration` should be validated to be a number within the limits defined in `CONFIG`.
*   **Data Import Vulnerability:** The `importInput` element suggests a feature to import data. Importing a malicious or malformed file could corrupt the application's state or introduce XSS vulnerabilities if the imported data is not rigorously sanitized and validated using the same `normalize*` functions.

### 2. Performance Implications

*   **DOM Rendering:** The event observers for `tasks:updated` and `settings:updated` both call `renderTasks()`. If `renderTasks()` re-renders the entire task list from scratch every time a single task changes, it will cause poor performance with a large number of tasks. This can lead to a noticeable lag in the UI.
*   **Synchronous `localStorage` Access:** The `loadState` function performs multiple synchronous reads from `localStorage` on startup. While generally fast, this blocks the main thread and can delay the initial application paint, especially if the stored data is large.
*   **Frequent DOM Updates:** The `timer:updated` event fires frequently (likely every second). The `updateTimerDisplay` function needs to be highly efficient and should only update the specific parts of the DOM that have changed (e.g., the time text, the progress bar width) to avoid unnecessary layout recalculations.

### 3. Best Practice Violations

*   **Monolithic Structure:** The entire application logic is contained within a single, large IIFE (Immediately Invoked Function Expression). This makes the code difficult to read, maintain, and test. It violates the principle of separation of concerns.
*   **Global State Management:** The application relies on a single, mutable global `state` object that is modified from various places. This makes it hard to track how and when the state changes, leading to potential bugs and complexity. A more structured state management pattern is recommended.
*   **Magic Strings:** The code uses string literals for timer modes (`"work"`, `"idle"`) and event bus names (`"tasks:updated"`). This is error-prone, as a typo will not be caught by any linter and will silently break functionality. These should be defined as constants.
*   **Mixing Concerns:** The `loadState` function is responsible for loading data from storage, normalizing it, and also contains business logic (e.g., inferring the selected task, checking if the timer was running). These concerns should be separated into dedicated modules or functions (e.g., a storage module, a state initialization module).
*   **Weak Conditional Check:** The check `if (typeof renderWeeklyChart === "function")` suggests a fragile architecture where the existence of a function is not guaranteed. This indicates a potential issue with code loading or organization.

### 4. Suggestions for Improvement

1.  **Refactor into ES Modules:** Break the `app.js` file into smaller, focused modules (e.g., `constants.js`, `state.js`, `ui.js`, `timer.js`, `storage.js`). This will dramatically improve readability, maintainability, and testability.
2.  **Sanitize All User Input to Prevent XSS:** When rendering task titles or any other user-provided content, always use `element.textContent = ...` instead of `element.innerHTML = ...`. This treats the content as plain text and prevents the browser from interpreting it as HTML.
3.  **Adopt a State Management Pattern:** Encapsulate the `state` object. Create specific functions for updating the state (e.g., `addTask(task)`, `updateSetting(key, value)`). These functions would be the only place state is modified. After an update, they can emit an event to signal that the UI should re-render.
4.  **Optimize DOM Rendering:** Modify the `renderTasks` function to be more efficient. Instead of a full re-render, identify which tasks are new, changed, or removed, and only apply those specific changes to the DOM.
5.  **Use Constants for Identifiers:** Move all string literals for event names, timer modes, and storage keys into the `CONFIG` object. This centralizes configuration and prevents bugs from typos.
    ```javascript
    // Example for timer modes
    const CONFIG = {
      // ...
      timerModes: Object.freeze({
        WORK: "work",
        SHORT_BREAK: "shortBreak",
        LONG_BREAK: "longBreak",
        IDLE: "idle"
      }),
      // ...
    };

    // Usage
    if (state.timer.mode === CONFIG.timerModes.IDLE) { /* ... */ }
    ```
6.  **Strengthen Data Validation:** Make the `normalize*` functions more robust. Ensure every field from `localStorage` or an imported file is validated for type, format, and range. If validation fails, fall back to a safe default value.

## âœ… Action Items

Based on this automated review, consider the following actions:

1. ğŸ”´ **Address Critical Issues**: Fix all security vulnerabilities before merging
2. ğŸŸ  **Review High Priority**: Investigate high-priority issues and determine appropriate fixes
3. ğŸŸ¡ **Consider Medium Priority**: Evaluate medium-priority suggestions for code quality improvement
4. ğŸ§ª **Add Tests**: Ensure adequate test coverage for all new code paths
5. ğŸ“š **Update Docs**: Update documentation to reflect code changes
6. ğŸ‘¥ **Peer Review**: Request manual peer review from team members

---

**Review Generated**: 2025å¹´ 10æœˆ 27æ—¥ æœˆæ›œæ—¥ 22:42:33 JST
**Review Type**: Alternative Implementation (Pattern Matching + AI)
**Commit**: `b2afeaa` (`HEAD`)

> âš ï¸  **Note**: This is an automated alternative review. For production-grade analysis, use CodeRabbit CLI or comprehensive manual review.

